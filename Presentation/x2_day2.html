<!DOCTYPE html>
<html>
  <head>
    <title>(X2) C++ Focus On STL – Day 2, Optional Part</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet, please also change EACH 'styling-by:' -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies approximately 2/3 of the page width. So only add
  little information, preferably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ STL]: 00_topics.html#agenda

# [C++ STL] – Odds and Ends
.center[(Day 2, Optional)]

-------------------------------------------------------------------------------

* [Extensions Provided by Boost		](#stl_boost_extensions)
* [STL-Concurrency Support		](#stl_concurrency_support))
* [STL-Quirks and Shortcomings		](#stl_quirks_and_shortcomings)
* [Micro-Project Suggestions		](#micro_project_suggestions)

-------------------------------------------------------------------------------

---
template: plain
name: stl_boost_extensions
header: ## Extensions Provided by Boost

[Boost Platform]: http://www.boost.org

From the libraries available on the [Boost Platform], probably the following are
the most interesting to augment what is provided in the STL:

* With respect to (additional) containers:

  * [Boost.Bimap	](#boost_bimap)
  * [Boost.MultiIndex	](#boost_multi_index)
  * [Boost.PropertyTree	](#boost_property_tree)

* With respect to (additional) algorithms:

  * [Boost.Algorithm	](#boost_algorithm)

* With respect to implementing Iterators:

  * [Boost.Iterator	](#boost_iterator)

* As an alternative to the STL iterator interface for algorithms:

  * [Boost.Range	](#boost_range)

---
template: plain
name: boost_bimap
header: ### Boost.Bimap

[Boost.Bimap]: http://www.boost.org/doc/libs/release/libs/bimap/doc/html/index.html
[Boost Platform]: http://www.boost.org

[Boost.Bimap] semantically._[] combines two maps so that

* efficient Bidirectional Lookup is provided, or
* as a concrete example
  * look-up IP-Numbers for Host-Names, and
  * llok-up Host-Names for IP-Numbers.

<!--
.I[
For more information on bidirectional maps see:
http://www.boost.org/doc/libs/release/libs/bimap/doc/html/index.html
]
-->

.F[:
The technique used to implement that kind of bidirectional lookup has not been
researched for the purpose of that presentation. But it can be assumed – as for
most libraries available on the [Boost Platform] – that is at least as
performant as an equivalent "home-grown" solution based on STL components.
]

---
template: plain
name: boost_multi_index
header: ### Boost.MultiIndex

[Boost.MultiIndex]: http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html
[DSL]: https://en.wikipedia.org/wiki/Domain-specific_language

[Boost.MultiIndex] is the "in memory" equivalent for data base table, i.e.

* by means of very advanced template programming a versatile parametrized class
  is provided
* extending the principles of a map to multiple columns,
  * each of which may be
    * indexable (or not)
    * unique (or not)
  * …

Note that the complexity of advanced template programming is mostly on the
implementors side.

.N[
From the client's perspective it rather appears as [DSL] that can be used in a
"Cook-Book" style, following and extending the examples from the documentation.
]

<!--
.I[
For more information on multi-index tables see:
http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html
]
-->

---
template: plain
name: boost_property_tree
header: ### Boost.PropertyTree

[Boost.PropertyTree]: http://www.boost.org/doc/libs/release/doc/html/property_tree.html
[GoF-Composite]: https://en.wikipedia.org/wiki/Composite_pattern

[Boost.PropertyTree] provides a data structure close to the [GoF-Composite]
design pattern.

It allows for

* hierarchical nesting (in principally unlimited depths)
  * of pairs of
    * keys and
    * values,
  * with the latter introducing recursion by
    * supporting property (sub-) tree
    * besides atomic elements.

.N[
Property trees (from Boost) are especially if it is necessary to make the
contained information persistent.
]

<!--
.I[
For more information on property trees see:
http://www.boost.org/doc/libs/release/doc/html/property_tree.html
]
-->

---
template: plain
name: boost_property_tree
header: #### Property Tree Serialisation Formats

[XML]: http://www.xml.com/pub/a/98/10/guide0.html?page=2#AEN58
[JSON]: http://json.org/
[JavaScript]: https://simple.wikipedia.org/wiki/JavaScript
[INFO File]: http://www.boost.org/doc/libs/release/doc/html/property_tree/parsers.html#property_tree.parsers.info_parser
[INI-Files]: https://en.wikipedia.org/wiki/INI_file

There are several serialisation formats to chose from when a property tree is
stored to a file or read-back:

* [XML]  
  with pre-defined tags (**not** any generic XML structure);

* [JSON]  
  a hierarchical data format (made popular by [JavaScript]) for simple
  data exchange in web applications and elsewhere;

* [INFO File]  
  a hierarchical format (much similar to the former), which was specially
  designed for storing a property tree in a text file;

* [INI-Files]  
  as in early versions of  MS-Windows.._[]

.F[:
When storing to and reading from ini-files there are limitations to the property
tree content, especially ini-files were not designed to hold (and easily edit)
nested data structures.
]

---
template: plain
name: boost_algorithm
header: ### Boost.Algorithm

[Boost.Algorithm]: http://www.boost.org/doc/libs/release/libs/algorithm/doc/html/index.html

[Boost.Algorithm] extends the
[Algorithm Dimension](04_day2.html#stl_algorithm_extensions) of the STL.

E.g. there are algorithms applicable to containers

* for efficiently sub-sequences
* applying comparisons
* … (and more) …

Since 2011 with each of the released ISO standards._[] parts of this library
were included.

.N[
Therefore [Boost.Algorithm] also provides a way to get (some) C++11/C++14
compatibility even if not provided by the compiler vendor.
]

.F[:
I.e. at the time of writing this, with C++11/14.
]

<!--
.I[
For more information on extended algorithms see:
http://www.boost.org/doc/libs/release/libs/algorithm/doc/html/index.html
]
-->

---
template: plain
name: boost_iterator
header: ### Boost.Iterator

[Boost.Iterator]: http://www.boost.org/doc/libs/release/libs/iterator/doc/index.html

[Boost.Iterator] is two things:

1. It is a clean-up (beyond a pure re-wording) for the
   [Iterator Categories](04_day2.html/#iterator_categories) as originally
   specified with C++98.

2. It helps to avoid much systematic code when implementing new iterators.

<!--
.I[
For more information on extensions to iterators see:
http://www.boost.org/doc/libs/release/libs/iterator/doc/index.html
-->

---
template: plain
name: boost_range
header: ### Boost.Range

[Boost.Range]: http://www.boost.org/doc/libs/release/libs/range/doc/html/index.html
[U*ix Pipeline]: https://en.wikipedia.org/wiki/Pipeline_%28Unix%29

[Boost.Range] implements all STL algorithms with a different interface:

* Instead of supplying two iterators to specify a range by the element it starts
  with and the first element beyond its end,

* **a single argument** has to be specified
  * which is a **model of some a range concept**, and
  * can be created in various ways.

Of course, creating a range from two iterators is still possible – but it is not
any more the **only** way, as it is with the classic STL API.

.N[
Even more flexibility is achieved with respect to ranges by utility operations,
e.g. to directly feed the output from one algorithm as input to another one.._[]
]

.F[:
As for this operation also an overload is defined for `operator|`, those who are
accustomed to [U*ix Pipeline]s._[] might be appealed also by the nifty look!
]

---
template: plain
name: stl_concurrency_support
header: ## STL Concurrency Support

[Concurrency Support]: http://en.cppreference.com/w/cpp/thread

Though C++11 introduced substantial [Concurrency Support] in the language and
library 

* the STL **does not provide a direct interface** to distribute work among
  several threads, as a means to improve performance on multi-core CPUs, instead

* the STL specification gives leeway to exploit chances for parallelizing
  independent parts of the work,

as long as it stays within the limits of the specified algorithmic complexity.

.W[
The problem is not that STL algorithms cannot be parallelized – it is rather
that developers might not be aware that it does.
]

---
template: plain
name: parallelizing_transparently
header: ### Parallelizing Transparently

E.g. it is **unspecified** by the ISO standard

* in which order `std::count_if` accesses the sequence to process
* which algorithm is used by `std::sort`

Therefore a conforming implementation could well be split the work over a number
threads, given its complexity is O(N) or O(N×log<sub>2</sub>(N) respectively.

.N[
If not explicitly specified for an algorithm, **no particular order** should be
assumed in which the elements on a container are accessed.
]

As this may not have been the case in the past,._[]

* the problem might occur without warning,
* when old code is compiled with a new library version,
* that implements parallelized algorithms without giving notice.

.F[:
The author confesses guilty for having used at least one example to demonstrate
the use of STL algorithms, that had a stateful functor, hence depending on
linear sequential access of container elements, front to back, but the algorithm
used in the example didn't guarantee this!
]

---
template: plain
name: parallelizing_explicitly
header: ### Parallelization Explicitly

If a given library implementation does not exploit chances for parallelizing,
it may be done explicitly.

Given there are four CPU cores, sorting a large._[] array might be done by

* **first** sorting four independent, equally sized segments in four threads –
  using `std::sort` and a bit of arithmetic with respect to the borders,

* **then** merging the two bottom and the two top segments in two threads –
  using `std::inplace_merge` (and some recycled border calculation from
  the first step), and

* **finally** merging the two sorted sections resulting from the previous step –
  again using `std::inplace_merge` on the whole array.

.W[
Though the above sounds simple – and in fact is not that hard to achieve with
what is already provided by the STL – understand that any added complexity tends
to make a program harder to understand and more difficult to maintain.
]

---
template: plain
name: parallelizing_efficient
header: ### Improving Performance - A Word to the Wise

Before applying a performance improvement, be sure to understand the following:

* If some part of a complex task contributes 20% to its total runtime,._[]
  * a performance improvement of 30% wins 6% total,
  * a performance improvement of 50% wins 10% total, and
  * **no** performance improvement will ever win more than 20%.
* Other if some part of a complex task contributes 90% to its total runtime,
  * then … (you will surely be able to do the math yourself).

.N[
The total effect of performance improvements are often hard to predict.
]

Therefore:

* **Measure before you start** …  

… and be sure to measure correctly and check the results for plausibility!

.F[:
This may or may not be much: if applied to a large application, **most** of
its whole source code may not have that impact. When considering an algorithm
in isolation it may not be much if it is the core of the algorithm, not some
preparation, book-keeping, or handling of exceptional conditions.
]

---
template: plain
name: parallelizing_efficient
header: ### Scaling for Multiple Cores

[Packaged Task]: http://de.cppreference.com/w/cpp/thread/async

The following is well-known – and can be demonstrated by measurements:

.N[
To increase performance it is contra-productive to split a CPU-bound task to
more threads as there are physical cores.._[]
]

When parallelizing with [Packed Tasks] in many cases

* the decision in many cases is best left to the library (implementation),
* assuming it has platform or operating system specific means to adapt actual
  (hardware) concurrency in the optimal way.

.W[
**Explicitly exempt** from that advice are more or less sophisticated
networks of **tasks that run independently** from each other,
**communicating via buffered pipelines**.
]

**Such designs easily deadlock if the library is allowed to silently turn
asynchronous into synchronous calls.**

.F[:
Or at least to more threads as there independent partial hardware processing
units that can work physically concurrent, like there are in hyper-threading
architectures.
]

---
template: plain
name: stl_quirks_and_shortcomings
header: ## STL-Quirks and Shortcomings

[Scott Meyers]: http://www.aristeia.com/

Though the STL has been designed by only two original contributors and
therefore has a quite uniform look&feel, there is some "historic ballast"
that is difficult to get rid of.

The areas considered on the following pages are:

* A few case [Inconsistent naming](#stl_naming_inconsistencies).

* Some non-obvious [Peculiarities of "Big-O"](#stl_big_o_peculiarities)
  complexity specifications.

Both are considered more closely on the next two pages.._[]

.F[:
To give credit where credit is due: this whole section was inspired by some
sequences from the following [Scott Meyers] video, starting at
[minute 37:54](https://www.youtube.com/watch?feature=player_detailpage&v=5tg1ONG18H8#t=2274):
https://www.youtube.com/watch?v=5tg1ONG18H8
]

---
template: plain
name: stl_naming_inconsistencies
header: ### STL Naming Inconsistencies

[Stable Sort]: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability

Purging an element with a given value

* from an `std::list` and an `std:forward_list` is done with the member function
  `remove`, while
* from any associative container it is done with with the member function `erase`.

Sorting elements

* of an `std::list` or an `std::forward_list` needs to be done with the member
  function `sort`
  * which guarantees a [Stable Sort], while
* for any other sequential container it is done with the (non-member) algorithm
  `std::sort`,
  * which **is not guaranteed to be a stable sort**, and
  * as if this is desired `std::stable_sort` has to be used.

(More cases as those discussed above may exist.)

---
template: plain
name: stl_big_o_peculiarities
header: ### STL Non-Obvious "Big-O" Complexity

Usually operations are not implemented if this were only possible with a
substantial performance penalty.

* Therefore `std::vector` has no member function `push_font` as `std::deque` and
  `std::list` have …
  * … but you can still use the `insert` member function anywhere, though
   O(N<sup>2</sup>) performance.

* Nonetheless `std::binary_search` is applicable to linear lists and specified
  to have "good" O(log<sub>2</sub>(N)) performance …
  * … though in this case you would naively expect much worse O(N).

* Adding elements to an `std::vector` at its end is specified to run in
  amortized constant time,
  * even though the available space must be eventually enlarged,
  * an operation more and more expensive, each time it happens.

(More cases as those discussed above may exist.)

---
template: plain
name: micro_project_suggestions
header: ## Micro-Project Suggestions

Following are some suggestions for micro-projects involving the STL.

.pull-left[

For all projects there is some

* [Basic C++ Knowledge](#micro_projects_base_knowledge)

expected, given you may select from the following categories:

* [Container Centric](#stl_container_micro_projects)
* [Algorithm Centric](#stl_algorithm_micro_projects)
* [Extension Centric](#stl_extension_micro_projects)
* [Miscellaneous Others](#stl_miscellaneous_micro_projects)

]

.pull-right[
Besides focussing on a specific area the suggested micro-projects have a
difficulty specified for each project …
  
<!-- -->

| … on a scale&nbsp;|&nbsp;of four |
|------------------:|:-------------|
| *trivial:*        | 😉 😉 😉 😉      |
| *simple:*         | 😡 😉 😉 😉      |
| *advanced:*       | 😞 😡 😐 😉      |
| *challenging:*    | 😞 😱 😐 😎      |

]

If you find nothing among the micro projects which is of interest to you, feel
free to start your own.

.N[
You will receive any help to the best of the trainer's ability, but don't expect
a perfect sample solution at the end.
]

---
template: plain
name: micro_projects_base_knowledge
header: ### General Basic C++ Knowledge

Besides the knowledge areas listed in the *Requirements* section of each project,
you should be fluent in the following areas of C++:

General C++ syntax and concepts, as

* variable definition and scope,
* flow control mechanisms including the basics of exceptions,
* the basics of classes as extensions to data structures
* the (very) basics of inheritance and other OOP core features
* the instantiation syntax of templates._[]
* reading input from `std::cin` and writing output to `std::cout`.

Furthermore it *might* pay to develop a certain scheme of

* [Automated Testing](#automated_testing)

so that you do not need to run your program over and over again,
"manually typing some "test input" and "visually checking the output"
for the correct response.

.F[:
**Not:** How to define templated containers and algorithm though you will
probably gain some insight by working on the projects.
]

---
template: plain
name: automated_testing
header: ### Automated Testing

[TDD]: https://en.wikipedia.org/wiki/Test-driven_development
[Boost.Test]: http://www.boost.org/doc/libs/release/libs/test/doc/html/index.html
[Google Test]: http://code.google.com/p/googletest
[CppUnit]: http://cpunit.sourceforge.net/
[Cute]: http://www.ifs.hsr.ch/Cute.5820.0.html
[Qt's QTestLib]: http://doc.qt.io/qt-4.8/qtestlib-manual.html

There are many options to automate testing and as many frameworks that support
the [TDD] approach.

To name just a few (sorted in alphabetically, not by personal preference):

--------------------------------------------------------------------------------
.pull-left[

* [Boost.Test]
* [CppUnit]
* [Cute]

]
.pull-right[

* [Google Test]
* [Qt's QTestLib]
* …

]

<!-- -->

--------------------------------------------------------------------------------

If you are comfortable with one of the above **just use it** and test your
micro-project solution until you get "the green bar".

--------------------------------------------------------------------------------

For all others the following pages outline two "poor man's" approaches:._[]

* [Base your Testing on `assert`](#assert_based_testing)
* [Simplistic Homegrown TDD](#simplistic_home_grown_tdd)

.F[:
Proposing these alternatives has the only reason that using any of the TDD
frameworks from would introduce a dependency that can be avoided with by using
a few very basic "C++-Bordmittel".
]

---
template: plain
name: assert_based_testing
header: ####  Assertion Based Testing (1)

Assertion bases testing is based on … `assert`-ions.

The following demonstrates the approach with a test of the faculty function:._[]
```
#include <cassert> // necessary to access the 'assert'-macro
                   // (as a macro, there is no std::-prefix)

unsigned long long faculty(unsigned long long n) {
    return n ? n*faculty(n-1) : 1;
}

int main() {
    assert(faculty(5) == 120); // 1*2*3*4*5 => 120

    assert(faculty(2) == 2);   // 1*2 => 2
    assert(faculty(1) == 1);   // 1 => 1 (border case)
    assert(faculty(0) == 1);   // => 1 (mathematically correct!)
}
```

.F[:
In an attempt to stay with most simple of all thinkable solutions, the scheme as
outlined aboves applies the *"no news is good news"* principle, i.e. if you run
the program and **nothing at all** happens, everything works as expected.
]

---
template: plain
name: assert_based_testing_2
header: ####  Assertion Based Testing (2)

[String Streams]: http://de.cppreference.com/w/cpp/io/basic_stringstream

Making a program "trivially interesting" often involves some input and output.
The following applies `assert-based` testing via [String Streams].

First the candidate under test:
```
#include <iostream>
#include <string>

void say_hello(std::istream &in, std::ostream &out) {
    std::string name;
    while (in >> name)
        out << "hello, " << name << '\n';
}
```

Note that the above is not written as `main` program but just as a function.

If course, it could therefore be called that way and tried with manual input and
visually checking the response:
```
int main() {
    say_hello(std::cin, std::cout);
}
```

---
template: plain
name: assert_based_testing_3
header: ####  Assertion Based Testing (3)

Of course, what was originally intended was an automated test, possibly supplying
different input and comparing the output to an expectation:
```
#include <sstream>

int main() {
    {// ---------------------- test with just one name
        std::istringstream iss("world");
        std::ostringstream oss;
        say_hello(iss, oss);
        assert(oss.str() == "hello, world\n");
    }
    {// ---------------------- test border case (empty input)
        std::istringstream iss("world");
        std::ostringstream oss;
        say_hello(iss, oss);
        assert(oss.str() == ""); // <-- expect not even a newline
    }
    std::cout << "*** ALL TESTS PASSED\n"; // not any longer:
                                           // no news is good news
}
```

.F[:
Note the use of inner blocks to ease adding another test with a simple
Copy&Paste.
]

---
template: plain
name: simplistic_home_grown_tdd
header: ####  Simplistic Home-Grown TDD

This approach is a slight extension of the following macro, which turns out to
be extremely versatile in small demo programs:
```
#include <iostream>
#define P(what)\
    std::cout << "[" << __LINE__ << "] " #what " --> "\
              << (what) << std::endl
```

The intended use is to print expressions in a "self-documenting" way:
.pull-left[
```
#include <algorithm>

int main() {
    auto s = {3, 5, -4, 1, 12};
    auto r = std::minmax(s);
    P(s.first);
    P(s.last);
}
```
]
.pull-right[
The output produced when both fragments._[] are compiled together and run will
look as follows:._[]
```
[10] r.first ==> -4
[11] r.second ==> 12
```
(Assuming `P` was used in lines 10 and 11 of the source shown left.)
]

.F[:
Of course the macro definition may go into a header is included in every source
using `P`.
]

---
template: plain
name: simplistic_home_grown_tdd_2
header: ####  Simplistic Home-Grown TDD (2)

The obvious advantage over [Assertion Based Testing](#assert_based_testing) is:

* The values are included in the output.

The (also obvious) disadvantage is:

* There is no indication whether the output is what was expected.

The latter can be cured by adding another macro taking the expected value as
second argument and showing a different mark (`!=!` instead of `-->`) when the
actual value differs from the expected …
```
#define XP(what, expected)\
    std::cout << "[" << __LINE__ << "] " #what\
              << ((what) == expected ? " ==> " : " !=! ")\
              << (what) << std::endl
```

… with the drawback that now only the expected value is shown …._[]

.F[:
… though to print the actual value you only need to change back to the `P`-macro
… and purge the second argument for the moment … or introduce a pro-forma second
argument to `X` too which gets ignored … and of course now any self-proclaimed C
language expert world-wide will happily point out that a macro argument should
**never ever* be used twice … so its time to turn the page once more …
]

---
template: plain
name: simplistic_home_grown_tdd_3
header: ####  (Not any more so) Simplistic Home-Grown TDD (3)

… and therefore this is what finally connects all the untangled ends:._[]
```
#define XP(what, expected)\
    do {\
        const auto &w = what;\
        const auto &e = expected;\
        std::cout << "[" << __LINE__ << "] " #what " --> " << w;\
        if (w != e)\ 
            std::cout << " !=! " <<  e << " <-- (expected)";\
        std::cout << std::endl;\
    } while (0)

```

.F[:
It should be clear that we are quickly approaching the point at which it will
probably pay to give up the home-grown approach and switch to a full-blown
TDD framework.
]

---
template: plain
name: simplistic_home_grown_tdd_4
header: ####  (Not any more so) Simplistic Home-Grown TDD (4)

For the sake of completeness here is another test program …
```
#include <algorithm>
#include <sstream>
#include <iterator>

int main() {
    const int x[] = { 1, 5, 5, 8, 1, 12, 1, 5 };
    std::ostringstream oss;
    // do not copy any duplicates from the above sequence
    std::unique_copy(std::begin(x), std::end(x),
                     std::ostream_iterator<int>(oss, " "));
    XP(oss.str(), "1 5 8 12 ");
}
```

… and the message showing how `std::unique_copy` failed:._[]
```
[21] oss.str() --> 1 5 8 1 12 1 5  !=! 1 5 8 12  <-- (expected)
```

.F[:
Actually it is not so much `std::unique_copy` that failed – it exactly behaves
as specified – but a wrong expectation on the tester's side: not *all*
duplicates are skipped over, only *adjacent* duplicates.
]

---
template: plain
name: stl_container_micro_projects
header: ### Container Centric STL Micro-Projects

--------------------------------------------------------------------------------

1. [Implement a *Word Frequency Analysis* with an `std::map`](#wordfreq_analysis_map)
1. [Implement a *Word Frequency Analysis* with an `std::multiset`](#wordfreq_analysis_multiset)
1. [Transform a Text (File) into a *Word Position Table*](#text_to_wordpos_table)
1. [Transform *Word Position Table* back into a Text (File)](#wordpos_table_to_text)

--------------------------------------------------------------------------------

---
template: plain
name: wordfreq_analysis_map
header: #### *Word Frequency Analysis* with `std::map`

##### Difficulty

.N.center[
*trivial:* 😉 😉 😉 😉
]

##### Example

.pull-left[
From the following input …
```
beware the Jabberwock my son
beware the Jubjub bird and shun
the frumious Bandersnatch
```
]
.pull-right[
… produce that output:
```
Bandersnatch: 1
Jabberwock: 1
Jubjub: 1
and: 1
beware: 2
bird: 1
frumious: 1
my: 1
shun: 1
son: 1
the: 3
```
]

---
template: plain
name: wordfreq_analysis_map-r
header: ##### Requirements

Understand the concept of an STL map, used as:
```
std::map<std::string, int> word_freq;
```

Especially understand what the following expression returns, in both cases,
for an existing and a non-existing key used in the square brackets:
```
… word_freq[w] … // assume w is of type std::string or compatible
```

---
template: plain
name: wordfreq_analysis_map_1
header: ##### Steps to Solution

1. Implement the input loop:
   * extract words with `operator>>` from a stream into a string until EOF
   * update the count per word

2. Implement the output loop:
   * traverse all entries of `word_freq`
   * print the word and its frequency (one per line)

---
template: plain
name: wordfreq_analysis_map_q
header: ##### Questions

In which order do you expect the words to be printed?

How does this depend on the specify type of map used?

##### Advanced Aspects

How could the sort order of the words be changed?

How could the words be reproduced in "insertion order" (of its first occurrence)?

---
template: plain
name: wordfreq_analysis_multiset
header: #### *Word Frequency Analysis* with `std::multiset`

##### Difficulty

.N.center[
*simple:* 😡 😉 😉 😉 
]

##### Example

.pull-left[
From the following input …
```
beware the Jabberwock my son
beware the Jubjub bird and shun
the frumious Bandersnatch
```
]
.pull-right[
… produce that output:
```
Bandersnatch: 1
Jabberwock: 1
Jubjub: 1
and: 1
beware: 2
bird: 1
frumious: 1
my: 1
shun: 1
son: 1
the: 3
```
]

---
template: plain
name: wordfreq_analysis_multiset_r
header: ##### Requirements

Understand the concept of an STL multiset, used as:
```
std::multiset<std::string, int> word_freq;
```

Understand (or look-up)

* how the number of indices with the same value can be determined, and
* how to skip over all but the first in a loop.

---
template: plain
name: wordfreq_analysis_multiset_s
header: #####  Steps To Solution

1. Implement the input loop:
   * extract words with `operator>>` from a stream into a string until EOF
   * update the count per word

2. Implement the output loop:
   * traverse the entries of `word_freq`
   * determine the frequency of a word (by the number of entries existing for
     it)
   * print the word and the number of occurrences (in a single line)
   * skip over all the following entries for that word

---
template: plain
name: wordfreq_analysis_multiset_q
header: ##### Questions

In which order do you expect the words to be printed?

How does this depend on the specify type of map used?

##### Advanced Aspects

How could the sort order of the words be changed?

If no particular sort order is required, were it possible to use an
`std::unordered_multiset`?

(Why? Isn't it that the order of traversal is arbitrary – so, if you tried, did
it possibly work only by chance?)

---
template: plain
name: text_to_wordpos_table
header: #### Text to *Word Position Table*

##### Difficulty

.N.center[
*simple* to *advanced:* 😡 😉 😉 😉 / 😞 😡 😐 😉
]

##### Example

.pull-left[
From the following input …
```
beware the Jabberwock my son
beware the Jubjub bird and shun
the frumious Bandersnatch
```
]
.pull-right[
… produce that output:
```
Bandersnatch: 4.2 
Jabberwock: 2.2 
Jubjub: 3.2 
and: 3.4 
beware: 2.0 3.0 
bird: 3.3 
frumious: 4.1 
my: 2.3 
shun: 3.5 
son: 2.4 
the: 2.1 3.1 4.0 
```
]

---
template: plain
name: text_to_wordpos_table_r
header: ##### Requirements

Understand that

* input analysis **requires two nested loops**

and how to

* extract a full from a stream into an `std::string` using`std::getline`,
* extract a world from stream into an `std::string` using `operator>>`,
* turn an `std::string` into an `std::istringstream`.

Also understand what in the following fragment is acceptable inside the square
brackets and what is the (type of) the resulting expression.
```
struct line_pos {
    int line, pos;
    line_pos(int line_, int pos_) : line(line_), pos(pos_) {}
};
std::map<std::string, std::vector<line_pos>> word_tab;
…            
//              vvv------- what type can go here?
    … word_freq[ … ] …     // and
//    ^^^^^^^^^^^^^^------ what is the result of this?
```

---
template: plain
name: text_to_wordpos_table_s
header: #####  Steps To Solution

1. Implement the two nested input loop:
   * the outer loop needs to read full lines until EOF
     * while taking care of a line count (= total number of lines read so far)
   * turn these line into an `std::stringstream` from which
   * the inner loops extracts all contained words
     * while taking care of the position count (= number of words read from
       **this** line)

2. Implement the two nested output loop:
   * traverse the entries of `word_tab`
     * print the word (element `first` of `std::pair<std::string, … >`)
   * in a **nested** loop traverse the line and position numbers (element
     `second` from `std::pair< … , std::vector<line_pos>>`)
     * print all line and position numbers following the word they belong
       to …
     * … then add a line end (`\n` or `std::endl`)

---
template: plain
name: text_to_wordpos_table_q
header: #####  Questions

Might it make sense to use `std::copy` as part of the solution?

In the input loop?

In the output loop?

---
template: plain
name: wordpos_table_to_text
header: #### *Word Position Table* to Text

##### Difficulty

.N.center[
*simple* to *advanced:* 😡 😉 😉 😉 / 😞 😡 😐 😉
]

##### Example

.pull-left[
From the following input …
```
Bandersnatch: 4.2 
Jabberwock: 2.2 
Jubjub: 3.2 
and: 3.4 
beware: 2.0 3.0 
bird: 3.3 
frumious: 4.1 
my: 2.3 
shun: 3.5 
son: 2.4 
the: 2.1 3.1 4.0 
```
]
.pull-right[
… produce that output:
```
beware the Jabberwock my son
beware the Jubjub bird and shun
the frumious Bandersnatch
```
]

---
template: plain
name: wordpos_table_to_text_r
header: ##### Requirements

Some experience with parsing input (like shown), e.g. by

* splitting an `std::string` at a given point,
* **or** combining `std::istringstreams` with nested `std::getline` calls._[],
  using separators different separators (`:` and `.`),
* **or** using regular expressions.

Understand that – in the general case – you need to have seen (and stored)
**all input** before you can produce output, as the first word might come last.

More depends on the solution, especially the data structure you chose to store
the input until output is produced.

The least amount of work will probably be necessary for this:
```
std::map<int, std::map<int, std::string>> word_tab;
```

.F[:
And therefore understand that `std::getline` should rather have been named:
`get_until_separator_and_swallow_the_latter`
]

---
template: plain
name: wordpos_table_to_text_s
header: #####  Steps To Solution

1. Implement reading input – **this is the more complicated part**
   * details depend on the way you chose to parse the lines

2. Implement generating output – this is the easy part
   * with the storage structure proposed, this can be solved with two simple
     (nested) range-`for` loops

##### Questions

How robust is your solution against "invalid input"?

How could a minor addition and modification._[] to the storage structure avoid
storing repeated words many times?._[]

.F[:
Some hints (if you need):  
1. Think along the lines of "pointers" but chose something "more in the spirit
of the STL".  
2. Each word needs to be stored exactly once (well, about that is the whole
idea of the improvement).  
3. Look-up what is the return value when inserting an element into an associative
container.  
4. … no, NO, **NO!** – leave it, more hints would take out all of the fun :-)
]

---
template: plain
name: stl_algorithm_micro_projects
header: ### Algorithm Centric STL Micro-Projects

--------------------------------------------------------------------------------

1. [Small Challenges (and Performance Testing)	](#small_challenges)
1. [Understand How `std::nextpermutation` Works	](#understand_nextpermutation)
1. [Permute of all Words in a Sentence		](#permutate_words_in_sentence)
1. [Implement a Basics `noduplicates` Algorithm	](#basic_noduplicates_algorithm)
1. [Improve the `noduplicates` Algorithm	](#improved_noduplicates_algorithm)

--------------------------------------------------------------------------------

---
template: plain
name: small_challenges
header: #### Small Challenges (and Performance Testing)

##### Difficulty

.N.center[
*trivial* to *challenging:* 😉 😉 😉 😉 / 😞 😱 😐 😎
]

##### Requirements

Online or offline reference for STL algorithms.

(If considered necessary, hints are given with the individual steps.)

.N[
Often the following challenges involve some practical performance testing.
It might pay to have a cursory look on the page that explains the
basics of [Getting Timings](#getting_timings) in an automatised way.
]

The solution itself._[] may often be "one-liner" so the "art" is rather to
select the STL algorithm most appropriate to solve the task at hand.

.F[:
This does not include the frame to set up the test data. But that part may often
be reused from a former challenge. Also understand that the goal is **not** to
come up with a clever but overly cryptic "one-liner". If more lines of code –
say a local temporary or type alias – will make the solution better
comprehensible, then add it!
]

---
template: plain
name: one_and_two_liners_groups
header: ##### Organisation into Groups

As the following are rather "Nano-" or "Pico-Projects" they are organised
slightly different as the other "Micro-Projects", and furthermore organised
as sub-groups.

--------------------------------------------------------------------------------

* [Modifying Sequence Operations	](#modifying_sequence_ops)
* [Non-Modifying Sequence Operations	](#nonmodifying_sequence_ops)
* [Partitioning and Sorting Operations	](#partitioning_and_sorting_ops)
* [Binary Search (on Sorted Ranges)	](#binary_search_ops)
* [Set Operations (on Sorted Ranges)	](#alternative_set_ops)
* [Heap Operations			](#alternative_heap_ops)
* [Minimum/Maximum Operations		](#minmax_ops)
* [Numeric Operations			](#numeric_ops)

--------------------------------------------------------------------------------

Modifying sequence operations are put first, as you will learn to create large
data sets, useful for some performance measurements.

After that goal is achieved, it is suggested **not** to work through all the
groups linearly, but "move around a bit", within **and** between the groups.

---
template: plain
name: modifying_sequence_ops
header: ##### Modifying Sequence Operations

[Algorithm Library]: http://en.cppreference.com/w/cpp/algorithm

C++11 added the algorithm `std::copy_if`. But the fact that this was "missing"
from C++98 was not that much a problem, as what it does can easily be done
by `std::remove_copy_if` too.

How?

Demonstrate with an example program!

Can you spot other "redundant functionality" in that sense, when skimming the
content of the [Algorithm Library]?

(The last question is posed not only with respect to the *modifying sequence
operations*, as covered in this section, but all of the algorithm library.)

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Fill different kinds of containers of `int`-values using `std::iota`._[]

Is the difference in speed for different container types measurable?

* Which is the least size that shows a (substantial) difference?
* Which container type performs best, which worst?
* Given there are 5000 elements, what is the order of magnitude for
  the difference between the best and the worst(1:2, 1:10, 1:100 …)?

--------------------------------------------------------------------------------

Name an algorithm that allows a more flexible way to generate the initial
content of an STL container, so that the container may be filled with:

* multiples of three
* random numbers
* primes

Demonstrate at least one of the above with the chosen algorithm and get the
timing.

.F[:
As `std::iota` became part of the library with C++11, it may not be available
with some older library version. In this case: skip hat step or find some other
algorithm set may be used.
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Given a random number generator with an *iterator style interface*,._[] how
could you use `std::copy_n` to fill a container with `N` random values?

As `std::copy_n` wasn't part of C++11: what were the difficulty if the same had
to be done with `std::copy`?

Why does an iterator style interface

* not fit to the requirements of `std::generate` / `std::generate_n`, and
* how could you transform that interface "on the fly" with a Lambda?

.F[:
A very bare-bones implementation of such a `RandomIterator` class might look as
follows (`std::rand` for simplicity and despite its well-known deficiencies):
```
   // random number generator with iterator-style interface
#include <cstdlib>
#include <iterator>

struct RandomIterator
        : std::iterator<std::input_iterator_tag, int> {
    RandomIterator operator++() {
        return *this;
    }
    int operator*() const {
        return std::rand();
    }
};
```
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

[`std::transform`]: http://en.cppreference.com/w/cpp/algorithm/transform
[Random Number Generation]: http://en.cppreference.com/w/cpp/numeric/random

From an `std::vector<unsigned int> x`, filled with ascending values from 0
to 9999, generate a second `std::vector<float> y`, filled with the square
roots of these numbers in `x`.._[]

Do the same for a vector filled with random positive numbers.

.W[
You may use this for generating large sequences of floats as test data,
but be sure to understand that such sequences are not really random in their
mathematical distribution.
]

So if the object under tests may be effected by the mathematical distribution
don't draw any conclusions from simple tests with floats generated in that
way.

Instead you may want to look at the [Random Number Generation] (sub-) library
introduced with C++11.

.F[:
Hint, if you need one: make friends with [`std::transform`].
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

[`std::transform`]: http://en.cppreference.com/w/cpp/algorithm/transform

Given the following scenario: there are two containers of the same size …

.pull-left[
… one holding instances of `MyClass` …
```
std::list<MyClass> objs;
… // fill with instances, say
  // a, b, c ...
```
]
.pull-right[
… the other simply holding `int` values:
```
std::vector<int> args;
… // fill with values, say
  // 12, 17, 108 ...
```
]

What is the most direct way (avoiding any loops, and also `std::for_each`)

* to call the member function `MyClass::foo(int)`
  * for the given objects with the given arguments,
  * and the return values
    * inserted to a stream `os`,
    * followed by a slash,
* i.e the equivalent of the following:._[]

```
os << a.foo(12) << '/' << b.foo(17) << '/' <<  c.foo(108) << '/' …
``` 

.F[:
Hint, if you need one: make friends with [`std::transform`].
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Device a scheme to

* turn the content of a `std::forward_list<unsigned long long>`
* into a text representation as `std::list<std::string>.._[]

If you have a translation environment based on C++98 only,

* base your solution on `std::copy` and an `std::sstream`, accessed via
  `std::istream_iterator`-s and `std::ostream_iterator`-s.

If you have a translation environment based on C++11

* base a (second) solution on `std::transform` plus `std::to_string`,
* and do a comparison which solution performs better.

Are the comparison results plausible?

(Depending on whether the results are plausible to you or not: Explain to
yourself or a colleague why they are or why you question the plausability!)

.F[:
The specific container types are not what is of interest here, it is the
challenge to transformation of a native type to its text representation.
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Fill a vector of notable size with random numbers in the following ways and get
the timings:

* Simply add new elements at the end.
* **First** set the number of vector elements accordingly (using `resize`).
* **First** set the vector data space accordingly (using `reserve`).

Try to get the timing for the *sizing* operations in the second and the third
case separately from the *filling* operation and chose a size at which the
differences become clearly noticeable.

Are the differences in the results plausible?

Explain why!

Repeat the above for

* an `std::unordered_multiset` (i.e. no resizing but space reservation), and
* an `std::array` of fixed size (i.e. no resizing and no space reservation).

Again: Are the results plausible and can you explain why?

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Device a technique with which you can generate a number of random integer values
with a given percentage of duplicates,._[] i.e. if "30%" duplicates were chosen
and then

* `std::sort` followed by `std::unique` is applied,
* it's size should shrink by 30%.

Use such a sequence (with its values random, but shuffled, and the chosen
percentage of duplicates) to determine the performance of copying it to

* an `std::vector`, then applying `std::sort` and `std::unique`, and
* an `std::set` (which implies sorting and uniqueness).

Which one is the faster, depending on the percentage of duplicates?

* Try this for no duplicates, 10%, 25%, 50%, 90%, and all duplicates (just
  all values the same in the last case).
* What changes if the sequence were (by chance) already sorted, or almost
  sorted – does this rather hurt or improve performance?

.F[:
Some hint, if you need one: create a unique, ascending sequence, then add the
percentage chosen by selecting values at random positions **within** that
sequence to its end, and finally "shuffle".
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Generate a large random sequence, then compare performance for removing half of
its values._[] using

* either the container specific member function `remove_if`.
* or the generic algorithm `std::remove_if`.

If you use the generic algorithm on a resizable container, also get rid of the
"(now) garbage at the end".

Do this for a selection of STL containers you are interested in.

(Doing it for all eight containers plus native arrays is a task requiring great
diligence, so you may well stop when you feel you have gathered enough insight.)

.F[:
Hint: if it can be assumed that even and odd numbers are equally distributed,
just remove the value with the lowest bit set.
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

From the following ways to copy the content of a container, which do you think
is fastest?
```
constexpr std::size_t N = …; // make an appropriate choice
std::vector<double> v(N);    // maybe fill with std::generate_n ??

/*1*/ std::vector<double> v1;
      std::copy(v.begin(), v.end(), std::back_inserter(v1));
/*2*/ std::vector<double> v2; v2.resize(v.size());
      std::copy(v.begin(), v.end(), v2.begin());
/*3*/ std::vector<double> v3; v3.reserve(v.size());
      std::copy(v.begin(), v.end(), std::back_inserter(v3));
/*4*/ std::vector<double> v4(v.begin(), v.end());
/*5*/ std::vector<double> v5(v);
/*6*/ std::vector<double> v6 = v;
/*7*/ std::vector<double> v7; v7 = v;
/*8*/ std::vector<double> v8(std::move(v)); // no later use of v !!
```

.N.center[
Do **not try** (right now) – think about it and give a **guess**.._[]
]

.F[:
Of course, after guessing you may practically prove (or disprove) your answer.
(Would you have answered differently for an `std::array`? Or if the element type
were `std::string`? If `v` were defined `const`?)
]

---
template: plain
header: ##### Modifying Sequence Operations (cont.)

Determine the speed (difference) of `std::copy` and `std::move` for containers
filled with

* `int`-s,
* `double`-s, and
* `std::string`-s.

It will most probably not make any difference whether the containers are filled
with random values, or all values are the same.._[]

Try it for some different containers, at least `std::array`, `std::vector`, and
`std::list` …

Furthermore, what difference makes it, if instead of the (generic) `std::copy`
or `std::move` algorithms

* `std:move_backward` or `std::move_backward` is used,
* the assignment operation for the container class is used,
* the source container `s` is moved to the target `t`, i.e. `t = std::move(s)`.

.F[:
But of course, as a diligent and *true STL scientist*, you might not rely on
your assumptions or "gut feelings", you might test it too …
]

---
template: plain
name: modifying_sequence_op_fwd_vs_bwd
header: ##### Modifying Sequence Operations (cont.)

To correctly copy or move **overlapping regions** within a container

.pull-left[
which of

* `std::copy` vs.
* `std::copy_backward`,
]
.pull-right[
and

* `std::move` vs.
* `std::move_backward`
]

needs to be used, depending on

* the location of the source (region)
* with respect to the destination position?

<p/>
.N.center[
If you came here from  
[adding a `universal_move` / `universal_copy` algorithm]  
go back now.
]

---
template: plain
name: modifying_sequence_op_rotate
header: ##### Modifying Sequence Operations (cont.)

Given three iterators `from`, `upto`, and `dest`, and assuming

* `from` closer to the container front as `upto`, and
* `upto` closer to the container front as `dest`, …

.pull-left[
```
std::rotate(from, upto, dest);
```
]
.pull-right[
… depict graphically the effect of the code fragment shown left.._[]
]

Then for the following, slightly changed assumptions

* `dest` closer to the container front as `from`, and
* `from` closer to the container front as `upto` …

.pull-left[
```
rotate(dest, from, upto);
```
]
.pull-right[
… again depict the effect of the code fragment shown left.
]

<!-- -->
.N.center[
If you came here from [adding a `slide` algorithm], go back now.
]

.F[:
Assume the layout of an `std::array` or `std::vector` with elements adjacent to
each other, draw the "state before" and the "state after" side by side, colorize
the area between `from` and `upto` in the "state before", the colorize the same
elements in their new position, in the state after.
]

---
template: plain
name: nonmodifying_sequence_ops
header: ##### Non-Modifying Sequence Operations

Considering `std::for_each` what are the advantages over:

* A "hand-written", index-based loop?
* A "hand-written", iterator-based loop?
* A C++11 range-`for` loop?

Would your answer be different if:

* Depending on the exact container type?
* If const-correctness needs to be ensured?
* If the loop does
  * not visit all elements of a container, or
  * needs to run "back to front"?
* Depending on whether the loop body
  * has to go in a functor (only option for C++98 and C++03), or
  * may alternately use a lambda (since C++11)?
* The loop body needs
  * access some variables in the callers scope (read-only), or
  * has to transfer a result back to the callers scope?
* If performance._[] is absolutely crucial?

.F[:
Concerning performance, maybe do some measurements, comparing
`std::for_each` with its alternatives.
]

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

Consider the group `std::all_of`, `std::any_of`, and `std::none_of`.

Is it that actually all three are required?

Can you demonstrate how one of it might be substituted by some other?

Might even each of the three substitute both of the others?

* If this is **not** so, which one(s) is/are the indispensable?
* If so, why have all three?
  * For performance?
  * For readability?
  * For both reasons?

Can you demonstrate – via taking timings – any "short-cut" effect, i.e. that
these algorithm run faster (or slower) depending on the particular data?

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

Do a performance comparison for `std::count_if`, depending on how the predicate
is handed over:

* via a lambda;
* via a functor and the relevant `operator()` overload defined
  * implicitly inline, or
  * explicitly `inline`;
* with a function pointer and the function implementation
  * in the same translation unit,
    * without the keyword `inline`, or
    * with the keyword inline, or
  * in a different translation unit (so "silent inlining by the compiler is
    made impossible).

Compare for constant conditions (e.g. count all elements less than 12) and for
the case (say: the limit 12) comes from a variable of the calling scope.

To complete the set of comparisons, also compare with a case for which the
plain `std::count` (comparison with fixed value) would have sufficed.
 
---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

Is the following code "correct" considering the leeway the STL specification
gives to implement `std::find_if`?
```
// find first value exceeding the sum of all the previous ones:
std::vector<int> v;
… // assume v filled somehow
assert(v.size() >= 1)
int sum = v.font();
auto pos = std::find_if(v.begin()+1, v.end(),
                        [&sum](int e) { return (e > sum)
                                            ? true
                                            : (sum += e, false);
                        });
```

Will your answer change if not the first of these values is looked up, but all
are counted with `std::count_if`?
```
auto cnt = std::count_if(v.begin()+1, v.end(),
                         [&sum](int e) { const auto res{e > sum};
                                         sum += e;
                                         return res;
                         });
```

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

[C++11 Multi-Threading]: http://en.cppreference.com/w/cpp/thread
[`std::async`]: http://en.cppreference.com/w/cpp/thread/async
[`std::count`]: http://en.cppreference.com/w/cpp/algorithm/count

.I[
The following is advanced in so far as it expects familiarity with
[C++11 Multi-Threading], at least to the degree that the use of
[`std::async`] is understood.._[]
]

Given your program executes on a multi-core CPU, try to beat the STL
implementation of [`std::count`] performance-wise: 

* Split the work to be done to two or four distinct data blocks (ideally chose
  this number according to the CPU capabilities),
* start the functions asynchronously,
* then collect (and finally add) the results.

.F[:
Of course, if you are hot now on trying to beat the STL library performance
on a multi-core CPU, that you are willing to acquire the necessary knowledge
right now, feel free to do so. Especially as using `std::async` is not **that**
hard and you need to know close to nothing about all the intricacies that
usually go with multi-threading.
]

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

Compared to the following code fragment …
```
struct LessThanLast {
    std::string &last;
    LessThanLast(const string &last_) : last(last_) {}
    bool operator(const std::string &e) {
        const std::string t = last; last = e; return (e < t);
    }
};
… // assume properly initialised std::vector<std::string> v
std::string last{};
auto pos = std::find_if(v.begin(), v.end(), LessThanLast(last));
```

… first guess, then try what gives the bigger performance improvement:

* while **keeping** the implementation of `LessThanLast::operator()` …
  * … replace the functor with an equivalent lambda;
  * … replace `std::find_if` with an equivalent hand-written loop;
* or **changing** the implementation of the functor to:

```
        const bool r = (e < last); last = e; return r;
```

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

[`std::find…`]: http://en.cppreference.com/w/cpp/algorithm/find
[`std::search…`]: http://en.cppreference.com/w/cpp/algorithm/search
[Boyer-Moore]: https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm
[Boyer-Moore-Horspool]: https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm
[Knuth-Morris-Pratt]: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm

**First:** Understand the difference between

* "finding" – i.e. the [`std::find…`]-algorithm family and
* "searching" – i.e. the [`std::search…`]-algorithm family.._[]

**Then:** Determine by a practical examination whether there is (still)
a substantial difference in speed, so that it could make sense to

* first check if the sequence to *search* for has only one member, and
* then eventually prefer *find* over it?

(Maybe given you have determined in advance that 90% of your searching
through the haystack is a for a needle of just one element.)

-------------------------------------------------------------------------------
[Boost.Algorithm]: http://www.boost.org/doc/libs/release/libs/algorithm/doc/html/index.html

If you have installed [Boost.Algorithm] you may include in your research also
implementations according to [Boyer-Moore], [Boyer-Moore-Horspool], and
[Knuth-Morris-Pratt].

.F[:
You see, it is not quite the difference of the colloquial use, but depending
on the outcome of the above, you might have an aide-memoir: *Finding* is better
than *Searching*.
]

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

[`std::equal…`]: http://en.cppreference.com/w/cpp/algorithm/equal

How does comparing two ranges for equal content with a generic algorithm from
the [`std::equal…`]-family perform in comparison to `operator==`, applied to the
container itself?

.pull-left[
Direct container comparison (`operator==` forwards to comparing element by element) …
```
std::vector<int> x, y;
… // fill with data
if (x == y) …
```
]
.pull-right[
… and the generic STL algorithm:
```
std::vector<int> x, y;
… // fill with data
if (equal(x.begin(), x.end(),
          y.begin(), y.end());
```
]

Repeat the comparison for an `std::deque` and an `std::list`.._[]

**First** think about this:  
Which obvious shortcut exists in the implementation of `operator==` for some
container class … (to hint further: except for `std::forward_list`)?

**Then**: Design your test cases to show that effect (too)!

.F[:
But also be sure to understand that the (probably much worse) results for the
`std::list` come from bad cache-hit-rates, caused by its non-contiguous memory
layout.
]

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

Given the following simple *Iota Generator with an Iterator Interface* …
```
class IotaGenerator 
    : public std::iterator<std::input_iterator_tag, int> {
    int value;
public:
    IotaGenerator(bool zero_origin = true)
        : value(zero_origin ? 0 : 1) {}
    IotaGenerator operator++() {
        return *this;
    }
    int operator*() const {
        return value++;
    }
};
```

… how could you use this to check whether some `std::vector<int>` holds
consecutively increasing values 0, 1, 2, … (up to its size less 1)?

* How would you chose 1-origin instead of 0-origin?._[]

.F[:
Only as a footnote as it is an aside to the algorithms, covered here: which
modifications would make sense to give the `IotaGenerator` an even broader
applicability, say generate a sequence from any start value with any step
width, or even with any expression calculating the next value?
]

---
template: plain
header: ##### Non-Modifying Sequence Operations (cont.)

[`std::equal…`]: http://en.cppreference.com/w/cpp/algorithm/equal
[SSCCE]: http://sscce.org/

The `std::equal…`-family has four members total. Decide._[] which one would
you chose to solve the following problems to compare …._[]

* … different containers of the same size, with the same element type;
* … containers of the same type, including the same element type, but of
  different size, for an equality within the limits of the shorter one;
* … containers of same type and with the same element type, the second
  possibly being shorter;
* … `std::list<std::string>` containers of equal size, ignoring differences
  with respect to upper/lower case;
* … `std::vector<int>` with `std::vector<double>`;
* … `std::array<double>` with `std::istringstream` holding `double` values in
  text form;
* … `std::vector<const char *>` with `std::vector<const std::string>` (based on
  the content of the strings if interpreted according to the C-rules).
* … `std::array<double>` with an array<std::string> of the same size, assuming the
  content of the strings is convertible to double;
* … as before but taking empty strings to represent zero.

.F[:
Of course it would be nice if you defend your decision by providing some
[SSCCE]s, and in case there are different equally simple solutions, if you point
out which one is more performant.
]

---
template: plain
name: partitioning_and_sorting_ops
header: ##### Partitioning and Sorting Operations

[`header <functional>`]: http://en.cppreference.com/w/cpp/header/functional#Comparisons

How would you sort …

* … an `std::array<int>` into decreasing order, using …
  * … a comparison function (i.e. function pointer)?
  * … a comparison functor?
  * … a comparison lambda?
  * … nothing of the above but "C++98 Bordmittel" only?  
    (Hint: see `header <functional>`)
* … an `std::vector<const char *>` (assumed to hold "classic C-strings") by
  their native character set order, i.e. like `std:strcmp` compares?._[]
* … an `std::vector<std::string>` ignoring differences in case?
* … an `std::forward_list<double>` into ascending order?
* … an `std::set<std::string>` into descending order?
* … an `std::array<int>` as shown in the example below:
  * 5, 7, -4, 33, 112, -5, 17, 12, -1, 33, 1024 (before sorting)
  * 5, 7, 12, 17, 33, 33, 112, 1024, -5, -4, -1 (after sorting)

.F[:
Note that this is slightly underspecified, as it is not said whether the order
of code points or code units are to be considered. The good news is: for UTF-8
coded `std::string`-s it doesn't matter - both orders are the same. For UTF-16
coded `std::wstrings` this is only true for characters in the BMP (assuming
`wchar_t` having 16 bits, what is the usual choice in MS-Windows and Java).
]

---
template: plain
header: ##### Partitioning and Sorting Operations (cont.)

[`std::sort`]: http://en.cppreference.com/w/cpp/algorithm/sort
[`std::stable_sort`]: http://en.cppreference.com/w/cpp/algorithm/sort

Do a performance evaluation of [`std::sort`] vs. [`std::stable`] using

* test containers with a varying percentages of elements comparing equal
  * from all elements unique
  * to all elements equal
* and element types with different "costs" for swapping.

.N[
To prepare your analysis, you might **think about swapping costs** first, or
even run some isolated tests in advance, so that the degree to which swapping
costs vary in your test-setup becomes clear.._[]
]

.F[:
As a hint for the lazy (or those who want to hurry to the core task): Choosing
`std::vector<int>` **as element type(!)** for the sorted container, vs. choosing
`std:array<int>` will dramatically vary the swapping cost, easily controlled
by the size of those **element** containers. Also, the comparison cost can
be controlled by defining an comparison operation that compares a smaller or
larger initial part of the element containers.
]

---
template: plain
header: ##### Partitioning and Sorting Operations (cont.)

[`std::partial_sort`]: http://en.cppreference.com/w/cpp/algorithm/sort

Given an `std::vector<int>`, holding unique but unsorted values from 1 to some
large upper limit, what approach is to prefer (over a full sort) if

* **first** the 1 … 25000 part needs to processed **fully sorted**, and only
* **then** it can be decide whether the 25001 … 50000 part needs to be processed
  (fully sorted), before
* **then** a decision can be made whether the 50001 … 75000 part needs to be
  processed,
* … (etc.) …

.F[:
As a hint, if you need one: look-up [`std::partial_sort`].  
And for all who ask themselves: Where might the above approach ever apply?  
Here is a story – not from software development and also not from "real live",
it has been invented for that purpose – but nevertheless, you might want to
listen (or read-on, resp.):   
In a small village there lives a farmer who's meadows became muddy from a long
period of rain. He wants to reinforce a path he often needs to take, so he calls
the lumber to bring some planks. Though the farmer doesn't know the exact length
of that pathway, it's clear that just some 10 or 20 planks will not suffice, may
be 60, 80, or even 100 are required (and of course this depends on the plank's
length too, the farmer doesn't know).  
The carpenter has far beyond 100 planks in his magazine, of which he could bring
as much as necessary to the farmer, but the planks are of vastly differing
length, and not stored sorted (only each one has been marked with its length
by pencil).  
And there are two more constraints: the number of planks the carpenter can
load on his decrepit [Tempo Dreirad] is strictly limit to 42. Furthermore, he
knows he will have to carry each plank separately (together with the farmer)
to its final position. To minimize that part of work it makes sense to arrange
the planks on the freight motor tricycle's cargo area for unloading in order of
decreasing length.  
And as our carpenter is a clever one, he carries out his work more or less in the
way described (abstractly) as the task at hand on this page.
]

[Tempo Dreirad]: http://www.tempo-dienst.de/Museum/Tempo1a.jpg

---
template: plain
header: ##### Partitioning and Sorting Operations (cont.)

[`std::partition`]: http://en.cppreference.com/w/cpp/algorithm/partition
[`std::stable_partition`]: http://en.cppreference.com/w/cpp/algorithm/stable_partition

Given an `std::vector<int>`, holding random values between 0 and 999
(total size say 10000 elements, so with many duplicates),

* how much faster is an approach
  * with partitioning only,
  * compared to a full sort
* if you only need to separate the groups
  * 0 … 9 – to be processed first,
  * 10 … 99 – to be processed second, and
  * 100 … 999 – to be processed last,
* with no particular order of elements within any these groups?

Compare the performance your approach against running a full sort.

.F[:
As a hint, if you need one: look-up [`std::partition`]. And as a separate but
related part, while you are at it, you may also lookup (or measure) the
difference to [`std::stable_partition`].
]

---
template: plain
header: ##### Partitioning and Sorting Operations (cont.)

Compare the speed of `std::is_sorted` to `std::sort`.

* Does the speed of any or both of the above depend on whether the container is
  already sorted when the operation is started?
* Assuming an already sorted container in both cases, how does the
  speed relation depend
  * on the container size, and
  * on the element type (say `int` vs. `std::string`)?

--------------------------------------------------------------------------------

[`std::sort`]: http://en.cppreference.com/w/cpp/algorithm/sort
[`std::is_sorted_until`]: http://en.cppreference.com/w/cpp/algorithm/is_sorted_until
[`std::inplace_merge`]: http://en.cppreference.com/w/cpp/algorithm/inplace_merge

Consider the case of a large STL container that needs to be sorted before
further use.

* Usually a large initial section is already sorted (from the last time the
  sort step was applied).
* Only, in the meantime, more entries have been appended to the end.

Given what the STL algorithms provides, what seems to be a good way?._[]

(Also compare the performance of this approach to to running a full sort.)

.F[:
As a hint, if you really need one: besides [`std::sort`], look-up
[`std::is_sorted_until`], and [`std::inplace_merge`].
]

---
template: plain
header: ##### Partitioning and Sorting Operations (cont.)

[C++11 Multi-Threading]: http://en.cppreference.com/w/cpp/thread
[`std::async`]: http://en.cppreference.com/w/cpp/thread/async
[`std::sort`]: http://en.cppreference.com/w/cpp/algorithm/sort
[`std::inplace_merge`]: http://en.cppreference.com/w/cpp/algorithm/inplace_merge

.I[
The following is advanced in so far as it expects familiarity with
[C++11 Multi-Threading], at least to the degree that the use of
[`std::async`] is understood.._[]
]

Try to beat the STL implementation of `std::sort` performance-wise: 

* Split the work to be done to two equal-sized data blocks.
* For each start an [`std::sort`] asynchronously,
* then wait for both to end, and
* combine the two sorted blocks with [`std::inplace_merge`].

Furthermore (optional):

* Outline the "recipe" to utilize 4 CPU cores, and
* any may be generalise that to 2<sup>N</sup> CPU cores.

(With the right approach, even the general case is easy to achieve … much easier
as you might thing at first – *but think at first* before you advance to an
implementation.)

.F[:
Learning to use `std::async` is not **that** hard, as and you need to know
close to nothing about the intricacies of general multi-threading.
]

---
template: plain
name: binary_search_ops
header: ##### Binary Search (on Sorted Ranges)

Make your familiar with the "Simple Random Test Patter Generator" [SRTPG] and
how it is used to analyse the performance of some associative containers.

Then adapt the tests of `std::set` to make use the [Set Operations] on sorted
ranges, provided as STL algorithms.

Is there a measurable difference in performance?

Are there any operations that can be done easily with STL algorithms but not
with the container classes or vice versa?

---
template: plain
name: alternative_set_ops
header: ##### Set Operations (on Sorted Ranges)

---
template: plain
name: #alternative_heap_ops
header: ##### Heap Operations

---
template: plain
name: minmax_ops
header: ##### Minimum/Maximum Operations

[`std::next_permutation`]: http://en.cppreference.com/w/cpp/algorithm/next_permutation
[`std::prev_permutation`]: http://en.cppreference.com/w/cpp/algorithm/next_permutation

Given that there is no other "memory" as the sequence to permute:._[]

* How can [`std::next_permutation`] determine
  * to return `true` in most any calls,
  * except when "it is through once" completely?
* Same for `std::prev_permutation`? (Only the other way round.)

So, if you came to an answer, explain the following code …
```
do {
    std::copy(std::begin(data), std::end(data),
              std::ostream_iterator<int>(std::cout));
    std::cout << std::endl;
} while (std::next_permutation(std::begin(data), std::end(data)));
```
.pull-left[
… shows 24 permutation here …
```
int data[] = { 1, 2, 3, 4 };
```
]
.pull-right[
… but fewer here:
```
int data[] = { 0, 8, 1, 5 };
```
]

Any idea?._[]

.F[:
Change `std::string` to `const char *` and things might even get more obscure …
]

* [Numeric Operations			](#numeric_ops)

---
template: plain
name: understand_nextpermutation
header: #### Understand `std::nextpermutation`

##### Difficulty

.N.center[
*trivial:* 😉 😉 😉 😉
]

##### Requirements

---
template: plain
header: #####  Steps To Solution

---
template: plain
name: permutate_words_in_sentence
header: #### Permute Words in a Sentence

##### Difficulty

.N.center[
*advanced*: 😞 😡 😐 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD

---
template: plain
name: basic_noduplicates_algorithm
header: #### A Basic `noduplicates` Algorithm

##### Difficulty

.N.center[
*simple:* 😡 😉 😉 😉 
]

##### Requirements

TBD

#####  Steps To Solution

TBD

---
template: plain
name: improved_noduplicates_algorithm
header: #### An Improved `noduplicates` Algorithm

##### Difficulty

.N.center[
*advanced* to *challenging:* 😞 😡 😐 😉 / 😞 😱 😐 😎
]

##### Requirements

TBD

#####  Steps To Solution

TBD

---
template: plain
name: stl_extension_micro_projects
header: ### Extension Centric STL Micro-Projects


--------------------------------------------------------------------------------

1. [Implement a *Basic Sequential Map* Container](#simple_sequential_map)
1. [Implement an *Advanced Sequential Map* Container](#advanced_sequential_map)
1. [Implement a Polymorphic Container *with* Inheritance](#polymorphic_container1)
1. [Implement a Polymorphic Container *without* Inheritance](#polymorphic_container2)
1. [Implement an "Iterator-Conscious" Container ](#iterator_conscious_container)

--------------------------------------------------------------------------------

---
template: plain
name: simple_sequential_map
header: #### A *Basic Sequential Map* Container


##### Difficulty

.N.center[
*advanced:* 😞 😡 😐 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: advanced_sequential_map
header: #### An *Advanced Sequential Map* Container

##### Difficulty

.N.center[
*challenging:* 😞 😱 😐 😎
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: polymorphic_container1
header: #### A Polymorphic Container *with* Inheritance

##### Difficulty

.N.center[
*advanced*: 😞 😡 😐 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: polymorphic_container2
header: #### A Polymorphic Container *without* Inheritance

##### Difficulty

.N.center[
*challenging:* 😞 😱 😐 😎
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: advanced_sequential_map
header: #### An *"Iterator Conscious"* Container

##### Difficulty

.N.center[
*challenging:* 😞 😱 😐 😎
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: stl_miscellaneous_micro_projects
header: ### Miscellaneous Other Micro-Projects

--------------------------------------------------------------------------------

1. [Timings of `std::array` Traversals](#std_array_traversal_timing)
1. [Timings of Container Traversals](#stl_container_traversal_timing)
1. [Timings of Unordered Associative Containers](#stl_unordered_assoc_timings)
1. [Timings of Various Callback Mechanisms](#stl_various_callback_timings)
1. [Practical Improvements to Time-Measurements](#improvements_to_get_timings)
1. [Estimate SBO-Improvements to Memory-Footprint](#estimate_sbo_improvements)

--------------------------------------------------------------------------------

---
template: plain
name: std_array_traversal_timing
header: #### Timings of `std::array` Traversals

##### Difficulty

.N.center[
*trivial* to *simple:* 😉 😉 😉 😉 / 😡 😉 😉 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: stl_container_traversal_timing
header: #### Timings of Container Traversals

##### Difficulty

.N.center[
*simple:* 😡 😉 😉 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD


---
template: plain
name: stl_unordered_assoc_timings
header: #### Timings of Unordered Associative Containers

##### Difficulty

.N.center[
*simple* to *advanced:* 😡 😉 😉 😉 / 😞 😡 😐 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD

---
template: plain
name: improvements_to_get_timings
header: #### Practical Improvements to Time-Measurements

##### Difficulty

.N.center[
*challenging:* 😞 😱 😐 😎
]

##### Requirements

TBD

#####  Steps To Solution

TBD

---
template: plain
name: estimate_sbo_improvements
header: #### [SBO]-Improvements to Memory-Footprint

[SBO]: https://akrzemi1.wordpress.com/2014/04/14/common-optimizations/#sbo

##### Difficulty

.N.center[
*advanced:* 😞 😡 😐 😉
]

##### Requirements

TBD

#####  Steps To Solution

TBD


</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


