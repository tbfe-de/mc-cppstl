<!DOCTYPE html>
<html>
  <head>
    <title>(3) C++ Focus On STL – Day 2, Part 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet, please also change EACH 'styling-by:' -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [für MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [für MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [für MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ STL]: 00_topics.html#agenda

# [C++ STL] – Iterators and Algorithms
.center[(Day 2, Part 1)]

.pull-left[
--------------------------------------------------------------------------------
**ITERATORS**

* [Principle of Iterators		](#stl_iterator_principles)
* [Iterator Categories			](#stl_iterator_categories)
* [Iterator Traits			](#stl_iterator_traits)

--------------------------------------------------------------------------------
]
.pull-right[
--------------------------------------------------------------------------------
**ALGORITHMS**

* [Iterator-Interface to Algorithms 	](#stl_algorithm_interface)
* [Callbacks from Algorithms		](#stl_algorithm_callbacks)
* [A Standard Algorithms Tour		](#stl_algorithm_tour)

--------------------------------------------------------------------------------
]

.center[**NOTE**]

At first this part puts the focus on Iterators – providing the "glue" between
algorithms – and then takes a closer view on algorithms, especially with
respect to their use of iterators and various forms of call-backs to adapt
their behaviour in detail.


---
template: plain
name: stl_iterator_principles
header: ## Principle of Iterators

[Gof Iterator Pattern]: http://www.informit.com/articles/article.aspx?p=1407357&seqNum=4
[Duck-Typing]: https://en.wikipedia.org/wiki/Duck_typing

Iterators provide a helping mechanism for container traversal, i.e. 

* processing all elements in a container,
* either in a specific order,._[]
* or simply with the guarantee each element is visited exactly once.

.N[
Note that STL-Iterators share the idea of the [GoF Iterator Pattern] but are
far from its proposed implementation.
]

STL style Iterators

* access the current element via the overloaded `operator*`;
* advance to the next element via the overloaded `operator++`;
* end of traversal by comparison with a special end-point iterator

and do all of this expecting an interface in the vein of [Duck-Typing].

.F[: Then, of course, there needs to be an ordering criteria, which for sequential
containers may be the sequential order created by insertion, and also trivially
exists for the traditional *ordered associative* containers based on binary
trees, **but not** for the hash-based containers (i.e. `std::unordered_set` and
`std::unordered_map` and their `multi`-variants).
]

---
template: linkinfo
graphic: STL-ContainerIterators
name: visualising_iterators
header: ### Visualising Iterators

Often iterators are visualised in graphics to support understanding their
principle.

* One common abstraction is to show iterators **pointing to** an element –
  the element they would return when dereferenced.

* Another possible abstraction is to show iterators pointing **in between**
  elements – right before the element they would advance over next.

---
template: plain
header: #### Visualising Iterators *Pointing To* Elements

[Undefined Behaviour]: http://en.cppreference.com/w/cpp/language/ub

##### Advantages

* It **is by far the most common** visualisation.
* It is immediately clear which element `operator*` will access.

##### Disadvantages

* Developers might first need to learn thinking in "asymmetric borders"._[]
* One more element must be assumed beyond the container-end to
  * visualise the iterator end position, and also
  * show how an iterator interacts with an empty container. 
* It must be made absolutely clear that this is a virtual element, **introduced
  only for the purpose of visualisation**.

.W[
**Therefore:**  
Any attempt to access that *"non-existing end point"* Element is
[Undefined Behaviour] according to the ISO Standard.
]

.F[:
After being accustomed to that kind of thinking it often becomes second nature
and thinking in symmetric borders may start feel unnatural.
]

---
template: plain
header: #### Visualising Iterators *Pointing Between* Elements

[Undefined Behaviour]: http://en.cppreference.com/w/cpp/language/ub

##### Advantages

* No virtual elements outside the container need to be assumed.
* Ranges (of affected elements) are visualised in a most natural way.
* It usually goes without saying that the iterator must not be moved
  outside of the container.

.W[
**Nevertheless:**  
Any attempt to move the iterator beyond the container borders
[Undefined Behaviour] according to the ISO Standard.
]

##### Disadvantages

* In common C++ literature this visualisation is hardly ever used.
* The *move direction* of the iterator must always be indicated to understand
  which element `operator*` will access.

---
template: linkinfo
graphic: STL-IteratorCategories
name: stl_iterator_categories
header: ## Iterator Categories

------------------------------------------------------------------------

* [Forward Iterators		](#forward_iterators)

------------------------------------------------------------------------

* [Bidirectional Iterators	](#bidirectional_iterators)

------------------------------------------------------------------------

* [Random Access Iterators	](#random_access_iterators)

------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorCategories
section: Unidirectional Iterators
name: forward_iterators
header: ### Forward Iterators

[ForwardIterator]: http://en.cppreference.com/w/cpp/concept/ForwardIterator

Iterators modelling the [ForwardIterator] concept may (only) be advanced into
one direction – i.e. forward from the begin to the end of a container.

Of the STL containers only one has iterators in that category, which is

* `std::forward_list<T>::iterator`

including the respective `const_`-variant.


---
template: withinfo
graphic: STL-IteratorCategories
section: Bidirectional Iterators
name: bidirectional_iterators
header: ### Bidirectional Iterators

[BidirectionalIterator]: http://en.cppreference.com/w/cpp/concept/BidirectionalIterator

Iterators modelling the [BidirectionalIterator] concept may be advanced in both
directions – forward from the begin to the end of a container, or backward from
the end (= reverse begin) to the begin (= reverse end).

.N[
The [BidirectionalIterator] concept **includes** the capabilities of the
[ForwardIterator Concept](#forward_iterators).
]

Of the STL containers seven have iterators of that category, which are

* `std::list<T>::iterator`
* and iterators of all eight associative containers,

including the respective `const_`-, `reverse_`-, and `const_reverse_`-variants.

---
template: withinfo
graphic: STL-IteratorCategories
section: Random Access Iterators
name: random_access_iterators
header: ### Random Access Iterators

[RandomAccessIterator]: http://en.cppreference.com/w/cpp/concept/RandomAccessIterator

Iterators modelling the [RandomAccessIterator] concept may efficiently access
elements at any given (valid) position in a container.

.N[
The [RandomAccessIterator] concept **includes** the capabilities of the
[BidirectionalIterator Concept](#bidirectional_iterators).
]

Besides addition and subtraction of integral numbers (which move the iterator
back or forth over that distance) by subtraction the size of the enclosed range._[]
can be determined.

.F[:
As in stead "size of enclosed range" also the wording "number of enclosed elements"
is a meaningful description, this again is a case where visualising iterators as
pointing **in between** elements is much more natural.
]

Of the STL containers three have iterators of that category, which are

* `std::array<T, N>::iterator`,
* `std::vector<T>::iterator` are
* `std::deque<T>::iterator`

including the respective `const_`-, `reverse_`-, and `const_reverse_`-variants.

---
template: plain
header: ### Limit-Checking of Random-Access Iterators

With respect to the following it should be noted that the ISO standard specifies
*Minimum-Requirements* only, which allow an highly efficient implementation, even
if this is traded for safety.

.W[
When a Random Access Iterators participates in an operation that moves it
outside the container borders the result is undefined.
]

Valid positions are also end-point positions, i.e. one beyond the container end
for regular iterators and its begin for the `reverse_`-variants.

.W[
On subtraction the result is only meaningful if the involved iterators refer
(to elements of._[]) the same container (including the end-point positions).
]

For any two iterators pointing to elements of different containers (of the same
type – otherwise it were a compile time error) it is guaranteed that they never
compare equal.

.F[:
If the visualisation of iterators **pointing to** elements is preferred.
]

---
template: plain
name: stl_iterator_traits
header: ## Iterator Traits

[Meta-Programming]: https://en.wikibooks.org/wiki/C%2B%2B_Programming/Templates/Template_Meta-Programming

[Type Traits] in general are an advanced concept with many uses in compile time
[Meta-Programming], but not limited to that area.

With respect to iterators only some minimal basic knowledge needs to be
acquired, which then can then be applied in
["cookbook-style"](#stl_iterator_cookbook_use) where necessary.

.N[
The class `std::iterator_traits` provides type conversions from an iterator
(type) to several related types, like the type resulting from dereferencing.
]

Its basic use is shown in an example on the next page.

.I[
For more information on iterator traits see:
http://en.cppreference.com/w/cpp/iterator/iterator_traits
]

---
template: plain
name: stl_iterator_cookbook_use
header: ### Cookbook-Style Use of Iterator Traits

Typically iterator traits come in handy when algorithms are implemented.

If an algorithm

* shall not only work with iterators from the STL containers,
* but also for native pointers (into native array)

it may be difficult ar first glance to determine the type of a derefenrenced
iterator in a generic way.

The following shows an elegant._[] solution applying `std::iterator_traits`:
```
template< … , typename Iterator, … >
void foo( … , Iterator it, … ) {
    typename std::iterator_traits<T>::value_type temp = *it++;
    …
}
```

.F[:
Less elegant solutions might overload `foo` for pointer types.
]

---
template: linkinfo
graphic: STL-IteratorUsages
name: stl_algorithm_interface
header: ## Iterator Interface to Algorithms

----------------------------------------------------------------------------

* [Iterators glueing …		](#iterators_as_glue)
* [… Containers with …		](#container_axis)
* [… Algorithms			](#algorithm_axis)

----------------------------------------------------------------------------

* [Input-Iterators		](#input_iterators)
* [Output-Iterators		](#output_iterators)

----------------------------------------------------------------------------

* [Successful und …		](#success_from_searching)
* [… Failed Search		](#failure_from_searching)

----------------------------------------------------------------------------

* [Fill State and …		](#state_from_filling)
* [… Removal Indication		](#removing_logically_only)

----------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorUsages
section: Iterators as "Glue"
name: iterators_as_glue
header: ### Iterators Glueing Containers with Algorithms

*Without* Iterators glueing containers with algorithms for

* approximately 40 algorithm (-families) and

* 12 containers in the ISO-Standard for C++98

about 480 (= 12 × 40) implementations would be necessary.._[]

.F[:
Even considering the fact that not every algorithm makes sense for every
container there would still be several hundred implementations be required.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Container Dimension
name: container_axis
header: ### Container-Axis

With C+98 three sequential and four associative containers were standardized.

C++11 now has a total of five sequential und eight associative containers.

(C++14 hat has not added more containers)

---
template: withinfo
graphic: STL-IteratorUsages
section: Algorithm-Dimension
name: algorithm_axis
header: ### Algorithm-Axis

Depending on how is counted int the ISO-Standard for C++98 there are about

Many algorithms come in "families" as eg.:

* A basic variant._[]
* A variant ending in `_if` for flexibly specifying predicates
* A variant ending in `_copy` to save the result in a new container
* A variant ending in `_copy_if` to combined the last two

.F[:
Not for any basic algorithm the following three variants make sense, so not all
the other three will be present. But if the second **and** the third exist then
also the fourth is present.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Input Iterators
name: input_iterators
header: ### Input Iterators

Input Iterators **alternately** have to be._[]

* dereferenced (`*`) for *read access* and

* *incremented* (`++`) for stepping to the next element.

.W[
If this rule is violated not for ever kind of container a problem will show.
Therefore algorithms based on input iterators need be thoroughly tested.
]

.F[:
The usual combinations of dereferencing with prefix and postfix increment will
work and especially dereferencing with postfix increment *exactly once* in a
loop over a whole container or a container range nicely express the semantic
restrictions and to guarantee such are followed.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Output Iterators
name: output_iterators
header: ### Output Iterators

Output Iterators **alternately* have to be.[]

* dereferenced (`*`) for *write access* and

* *incremented* (`++`) for stepping to the next element.

.W[
The usual combinations of dereferencing with prefix and postfix increment will
work and especially dereferencing with postfix increment *exactly once* in a
loop over a whole container or a container range nicely express the semantic
restrictions and to guarantee such are followed.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return Success from Search
name: success_from_searching
header: ### Search Success

For searching and related container operations success will be indicated via an
iterator to

* a valid element position **inside** the range

the algorithm operates on. To determine success a comparison will have be made
with the endpoint of that range.

.W[
If only a sub-range of a container `c` is specified which does not extend to the
end of the container, testing for success **must not** be done by comparing to
`c.end()` or `c.cend()` but to the actual endpoint of that range.
]

The element at the position the returned iterator indicates (of course) is the
one satisfying the search..[]

.F[:
The phrase "satisfying the search" is used loosely here because depending on the
operation the result may also be a limit separating two ranges of elements and
for certain types of searches also an iterator pair may be returned indicating
an element range.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return Failure from Search
name: failure_from_searching
header: ### Search Failure

For searching and related container operations failure will be indicated via
an iterator 

* comparing equal to the one specifying the end of the range

the algorithm operates on.

.W[
When searching through an empty container `c` the result will always compare
equal to `c.end()` or `c.cend()` respectively.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return State from Filling
name: state_from_filling
header: ### Returning Fill State

Algorithms filling a container – no matter whether by overwriting or
appending – will return

* the resulting fill state

which is an iterator past the element last written.

.N[
Retrieving the result from such algorithms._[] can be useful when new elements
later need to be added, after the ones from the previous operation.
]

.F[:
It should be understood that all the `_copy` variants from an algorithm family
have that feature. But not in each case the state change is in the iterator
specified as target for the result. So, to be careful, it is advisable to
*always* assign the result back to the iterator specifying the target.
]

---
template: withinfo
graphic: STL-IteratorUsages
name: removing_logically_only
section: Removal Indication
header: ### Indicating Removal Via Logical End

To achieve maximal independence of algorithms from containers a there is a
special pragmatic feature, that at first glance it may look inconvenient.

Generic Algorithms that "remove" elements from a container do not depend on
the containers which can be "physically shrunken".

.N[
Therefore these algorithms work also with native arrays or the STL class
`std::array`.
]

Removing elements will only happen "logically", i.e.

* the contained elements will just be re-arranged

* and the return value is the boundary between the elements "still valid"
  (considering what the algorithm was meant for) and the elements
  "in excess".._[]

.F[:
So clearly, "rearranging" means "bringing to the front" but there is no way to
predict what the elements between that boundary and the end of the container
will look like. (Though typically you'll find either the previous content –
which has been *copied* more to the front – or "removed" elements – which have
been swapped from the front.)
]

---
template: plain
name: iterators_in_algorithms
header: ## Iterators in Algorithms

Exclusively using iterators for the implementation of (STL) algorithms
provides a special flexibility.

Iterators most often are just simple (helper) classes with an implementation
specific for the container they are meant for.

.N[
So the data sources to be processed by an algorithm are technically not
restricted other than it must be possible to supply an iterator class. The same
is true for storing the results to target containers.
]

---
template: plain
header: ### Example Implementation Of the `copy` Algorithm

For a better understanding how iterators provide a special flexibility for
algorithms looking at a possible implementation of the `copy` algorithm like
it is available in the STL will help:
```
template<typename T1, typename T2>
T2 my_copy(T1 from, T1 upto, T2 dest) {
    while (from != upto)
       	*dest++ = *from++;
    return dest;
}
```

.F[:
If want to compile and test this algorithm in a program of your own you should
consider to rename it to `my_copy` avoiding a conflict with `std::copy`,
especially if somewhere in the code is a `using namespace std;` statement.
]

---
template: plain
header: #### Copy elements from `std::set` to `std::vector`

The `copy` Algorithm as previously shown easily copies between different kinds
of containers:
```
std::vector<int> v;
std::set<int> s;
…
v.resize(s.size());
std::copy(s.begin(), s.end(), v.begin());
```

As an ordinary iterator – like returned from `v.begin()` or `v.cbegin()` –
just overwrites existing elements but does not append new ones the target
container must be properly sized before:

---
template: plain
header: #### Appending On `std::vector`

##### Helper Class: `back_insert_iterator`

If the target container technically can grow by adding new elements instead of
sizing the target (and then overwriting elements) new elements can be added
directly. In this example the `push_back` member function is expected to exist
for the target and indirectly used via `std::back_insert_iterator`:
```
std::copy(s.begin(), s.end(),
          std::back_insert_iterator<std::vector<int>>(v)
);
```

.N[
Because in this and many of the following examples the argument lists for
calling an algorithm can get lengthy, there is a line break within that
argument to improve readability.
]

That way also different styles to format the code are shown.._[]

.F[:
The asymmetric parenthesizing style used in this example may or may not please
you but imitates the style used with curly braces.
]

---
template: plain
header: ##### Helper Function: `back_inserter`

Specifying the container type in the template argument list looks redundant but
is technically necessary to create a (temporary) object of the class
`std::back_insert_iterator` and constructor arguments cannot deduce types
from values in their argument list.

A little helper function._[] avoids the redundancy:
```
std::copy(s.begin(), s.end(), std::back_inserter(v));
```

.F[:
This function is provided by the STL and therefore doesn't need to be manually
implemented. Nevertheless showing the implementation may be of interest for
everybody who needs a solution in a similar of redundant type names.
```
namespace std {
    template<typename T>
    inline auto back_inserter(T &c) { return back_insert_iterator<T>(c); }
}
```
]

---
template: plain
header: #### Extending sequential Containers At Both Ends

Of course the class `std::back_inserter_iterator` and the helper function
`std::back_inserter` work for each class providing a `push_back` member
function, which are

* `std::list` and
* `std::deque`

and of course there also is a class `std::front_insert_iterator` and a helper
function `std::front_inserter` works for any class providing a `push_front`
member, which are

* `std::list`,
* `std::deque` and
* `std::forward_list`

---
template: plain
header: #### Inserting In an associative Container

##### Helper Class: `insert_iterator`

The example shows how all elements of an `std::list` can be copied to an
`std::set` – which of course will throw out duplicates according to the
nature on an `std::set`.._[]
```
std::list<MyClass> li;
…
std::set<MyClass> s;
std::copy(li.begin(), li.end(),
          std::insert_iterator<std::set<MyClass>>(s)
);
```

.F[:
Unless it is an `std::multiset`, of course.
]

---
template: plain
header: ##### Helper Function: `inserter`

Again there is a helper function to avoid the redundancy that comes from having
to specify the container type:

```
std::set<MyClass> s;
std::copy(li.begin(), li.end(), std::inserter(s, s.begin()));
```

What looks unusual is the extra argument,._[] which still makes sense for two
reasons:._[]

* The use of `std::insert_iterators` is also possible to extend sequential
  containers in the at any position (though this may not be an efficient way
  to add elements depending on the container type).
* For associative containers this argument may still be used as a hint to
  speed-up insertion.

.F[:
Not going too deep into the syntax and type deduction intricacies the problem
here is that the nested type lookup mechanism would be required to include
function overloads and default arguments – which it currently doesn't.
]

---
template: plain
header: #### Stream Iterators

Much like various forms of insert iterators classes forward an assignment_[]
to the `push_front`, `push_back`, or `insert` member function of the given
container, also other operations can be wrapped into small helper classes.

.F[:
More precisely an assignment to whatever type their dereferencing operations
return.
]

##### Writing To a Stream With `std::ostream_iterator`:

The next example inserts all elements from of `std::forward_list` to standard
output with a semicolon (`;`) appended after each value:
```
std::forward_list<long> fli;
…
std::copy(fli.begin(), fli.end(),
          std::ostream_iterator<long>(std::cout, ";")
);
```

.N[
Generating output that way requires the elements of the `std::forward_list` are
convertible to `long` – a no-op in this case.
]

In general, as stream insertion uses `std::operator<<`, any type will work for
which that operator is defined with a right-hand operand of the type specified
as template argument.

---
template: plain
header: ##### Reading From a Stream With `std::istream_iterator`:

The next example._[] extracts values of type `std::string` from standard input,
pushing each to the front of an `std::forward_list` so the last comes first if
later traversed with an (ordinary forward) iterator:._[]
```
std::forward_list<std::string> fli;
copy(std::istream_iterator<std::string>(std::cin),
     std::istream_iterator<std::string>(),
     std::front_inserter(fli)
);
```

.N[
Filling the `std::forward_list` that way requires what is extracted via the
`std::istream_iterator` is convertible to `std::string` – a no-op in this case.
]

In general, as stream extraction uses `std::operator>>`, any type will work for
which that operator is defined with a right-hand operand of the type specified
as template argument.


.F[:
You may well use the above example in a "cookbook style", simply changing what
needs obviously to be changed. But for those who want some deeper understanding
here are some hints:  
The "range" in the stream from which the input is extracted is specified via
two constructors of the class `std::istream_iterator` returning temporary
objects. The first has an argument which is an `std::istream` to be used as
data source. The second has no argument – i.e. the *default constructor* of
that class.  
Comparing these two object for equality determines when the range ends. So in
some way the operations `*` and `++` are forwarded to `operator>>`. For all
standard algorithms it is guaranteed that the use adheres to the requirements
of an [Input Iterator](input_iterators) and within these restrictions comparing
the two objects for equality returns `true` as long as there is more input
available.
]

---
template: plain
header: #### Native Pointers As Iterators

As syntactically the operations required from iterators are provided by native
pointers and semantically these operations adhere to the requirements for
[Random Access Iterators](#random_access_iterators)._[], all STL algorithms
can be applied to native arrays too.

##### Copying From a Native Array

Assuming a native array `data` as data source
```
double data[100]; std::size_t ndata{0};
```
and that after filling in some data the first `ndata` elements are valid:
```
std::copy(&data[0], &data[ndata], … );
```
OR:
```
std::copy(data, data + ndata, … );
```

.F[:
Note that a native pointer is allowed to point to the memory address **after**
the last element of a native array, only **dereferencing** a pointer to that
address is undefined behavior.
]

---
template: plain
header: ##### Copying Into a Native Array

Assuming a native array `data` as data sink:._[]
```
const auto endp = std::copy( … , … , &data[0]);
```

To convert the filling indicator into a count:
```
ndata = endp - data; // or: ... endp - &data[0]
```

.F[:
As there isn't any overflow control in that example the algorithm `std::copy`
is not a good choice if the amount of data copied into a native array cannot
be determined in advance. For a clean solution limit control may be provided
with a small helper class wrapping source iterators. But to the knowledge of
the author there is no standard class provided that could serve that purpose.
]

.W[
If the data source for produces more elements as fit in `data` memory directly
after the native array will be overwritten.
]

---
template: plain
header: #### Copying Between Different Container Types

```
using namespace std;
vector<double> v;

// from standard input float-s appended to vector ...
copy(istream_iterator<float>(cin), istream_iterator<float>(),
     back_inserter(v));

// ... to classic array (widening to double) ...
double data[100]; const auto N = sizeof data / sizeof data[0];

// ... (protecting against overflow) ...
if (v.size() < N) v.resize(N);

// ... (remembering filling state) ...
const auto endp = copy(v.begin(), v.end(), data);

// ... to set (truncating to integer) ...
set<int> s; copy(data, endp, inserter(s, s.begin()));

// ... to stdout with semicolon and space after each value
copy(s.begin(), s.end(), ostream_iterator<int>(cout, "; "));
```

.F[:
As long as there is assignment compatibility also the element type may differ
when copying between different containers.
]

---
template: plain
header: #### Copying Between Identical Container Types

[PODs]: http://www.cplusplus.com/reference/type_traits/is_pod/

While the `std::copy` algorithm may well be used to make a "1:1" copy of
containers of identical type, direct assignment makes more sense:
```
std::vector<MyClass> v1, v2;
…
v2 = v1;
```
Instead of (if necessary after `v2.clear()`):
```
std::copy(v1.begin(), v1.end(), std::back_inserter(v2));
```
.N[
Container specific assignments may – and will – utilize container specific
properties of the data structure used for storage **including** the element
type.._[]
]

.F[:
E.g. contrary to generic copying contiguous data storage of [PODs] may be
recognized, finally falling back to `std::memmove` or `std::memcpy` … (which
then may even be directly supported by specific hardware).
]

---
template: plain
header: #### Some Typical Algorithms By Example

The following code fragments assume an STL container
```
std::vector<int> v;
```
Which has been filled with data values.

##### Counting All Elements Equal To 542
```
auto n = std::count(v.begin(), v.end(), 542);
```

##### Locating the First Element Equal To 542

```
const auto f = std::find(v.begin(), v.end(), 542);
if (f != v.end()) {
    … // (first) matching element located
}
else {
    … // NO matching element exists
}
```

---
template: plain
header: ##### Removing All Elements Equal To 542

```
const auto end = std::remove(v.begin(), v.end(), 542);
```

Now the variable `end` holds an iterator that determines the new (logical) end.
If removals took place the original container will (still) be larger, but any
excess elements from hat point to the end should be ignored.

If the container size can be changed:
```
// physically remove excess elements
v.erase(end, v.end());
```

.N[
Code like shown above especially makes sense in generic templates, where the
actual container – i.e. the type of `v` – shall be kept flexible.
]

If a certain, typical use case of such templates will lead to sub-optimal code
which finally has an impact on run time performance, specializations for that
type may still be added.

---
template: plain
name: generic_vs_specific
header: ##### STL Algorithm vs. Specific Member Functions

When the class of a container is known there are alternatives to generic
algorithms, often in form of member functions. Such are usually simpler to use
and more efficient.

As it has been shown after using the **generic** algorithm to remove elements
resizable contaners must still be shrunken to their actual content.

.pull-left[
Less readable and often less efficient too:
```
v.erase(
    std::remove(v.begin(),
                v.end()),
    542);
```
]
.pull-right[
Better readable and always as efficient as possible:
```
v.remove(542);
```
]

In both cases the container type is not any longer fully generic but of course
the *data type* of that container still is.._[]

.F[:
Excluded now is e.g. an `std::array` as it cannot be resized at run time.
]

---
template: plain
name: stl_algorithm_callbacks
header: ## Callbacks from Algorithms

---------------------------------------------------------------------------------

* [Callbacks In General					](#callbacks_general)
* [Callback with Functor 				](#callback_with_functor)
* [Callback with Lambda					](#callback_with_lambda)
* [C++14 Extensions for Lambdas				](#cpp14_lambda_extensions)
* [Predicates For Algorithms – General Aspects		](#predicates_general)
* [Predicates For Algorithms by Example			](#predicate_examples))
* [Algorithms vs. Specific Member Functions		](#generic_vs_specific)

---------------------------------------------------------------------------------

---
template: plain
name: callbacks_general
header: ### Callbacks In General

By their nature algorithms are library code, but many need to do "call back"
into the application.

This is possible in three ways:

* Classic (C-) function handed over as function pointer:
  * specified is only the name of the function;
  * there are no parentheses enclosing arguments.

* Objects may overload their `operator()` member function – so called functors:
  * often a just a temporary object instance will be created by just using the
    class name;
  * in this case parentheses or braces may follow,
    * specifying constructor arguments;
    * if empty that means the default constructor is to be used.

* C++11 Lambdas

---
template: plain
name: callback_with_functor
header: ### Callback With Functor

A typical example is the algorithm `std::for_each`, running an internal loop
over all the elements in a container. The code to process each element is
supplied via a *call back* as third argument.

First a functor (that just prints all the elements after a colon):
```
struct PrintWords { // in a struct everything is public by default
    void operator()(const std::string &e) {
        cout << e << "\n";
    }
};
```

.N[
After the **class name** of the functor **follow round parentheses or curly
brackets, to instantiate a temporary. object (bound as argument).._[]
]

```
std::for_each(v.begin(), v.end(), PrintWords()); // (old) C++ Style
```
```
std::for_each(v.begin(), v.end(), PrintWords{}); // since C++11 also
```

.F[:
Instead of a temporary object also a named object may be instantiated which
then would be handed over **without** any parentheses or braces following it.
]

---
template: plain
name: callback_with_function
header: #### Comparison With Function

Using a function instead of a functor make the example look like this:._[]
```
void print_words(const std::string &e) {
    cout << e << "\n";
};
```
.N[
Now **no parentheses** must follow as the **name** of a function represents
a pointer to its start address – the **call** follows inside `std::for_each`.
]

```
std::for_each(v.begin(), v.end(), print_words);
```

.F[:
As an advanced feature that should not go completely without noting (though it
will not be covered further here) consider an addition to C++11, a new utility
type able to wrap any *Callable*, be it functors, functions, or lambdas (of
matching signature). While `std::function` may loosen coupling (which is
often desirable) also note that it will typically **introduce an extra level of
indirection for the at actual call**, leading to less locality in the code
(usually **not** desirable).

```
std::function<void(const std::string &)> myCallBack;
…
// then, at a later point: // ---------------------- more flexibility through reduced coupling
myCallBack = print_words;  // or: ... = PrintWords();
                           //         = PrintWords{}
                           //         = [](const auto &e) { cout << ": " << e << "\n"; }
                           // ----------------------- at the price of an extra indirection
std::for_each(v.begin(), v.end(), myCallBack);        // (not very visible in the code)

```
]

---
template: plain
header: #### Local Data In Functors

An advantage of a functor over a function is they can encapsulate local
variables.

Following is a slight modification of the previous example which  – using
`std::for_each` – prints all the elements of a container enumerated:
```
struct PrintWordsEnumerated {
    void operator()(const std::string &s) {
        std::cout << ++n << ": " << s << "\n";
    }
    PrintWordsEnumerated() : n(0) {}
private:
    int n;
};
```

---
template: plain
header: #### Handing Local Context to Functors

Using additional data members initialized in the constructor allows forwarding
of local context – like local variables – which then hands over the functor
to an algorithm:._[]
```
struct PrintWordsEnumerated {
    void operator()(const std::string &e) {
        os << ++n << ": " << e << "\n";
    }
    PrintWordsEnumerated(std::ostream &os_) : n(0), os(os_) {}
private:
    int n;
    std::ostream &os;
};
```

.F[:
Actually, in this case the reason for the flexibility added to the functor
probably is to reuse it for different sinks. Otherwise, as a global object
`std::cout` would have been available directly in functor's `operator()`.
]

Actual values are now to supply in the instantiation of the functor object:
```
std::for_each(v.begin(), v.end(),
              PrintWordsEnumerated(std::cout)); // (old) C++ style
```

```
std::for_each(v.begin(), v.end(),
              PrintWordsEnumerated{std::cout}); // since C++11 also
```

---
template: plain
header: #### Parameter From the Caller

The flexibility gained is important to hand over information from the local
calling context, like local variables or arguments the function itself
received, that now is handing over the functor to `std::for_each` (or any other
algorithm):
```
void foo(std::ostream &output) {
    …
    std::for_each(v.begin(), v.end(),
                  PrintWordsEnumerated(output));
    …
}
```

.N[
This can cleanly be done with functors only – or lambdas, covered next. It
**can not** be done with functions via additional arguments, as the argument
list must match the call from **inseide** `std::for_each`.
]

---
template: plain
header: #### Types Of Member Data In Functors

The type to chose depends on the purpose:

|Access            |Data Member       |Constructor Argument          |
|------------------|------------------|------------------------------|
|via copy          |constant value    |value or constant reference   |
|direct readonly   |constant reference|(constant) reference          |
|also modifying    |(plain) reference |(plain) reference             |

Reference member data **must never** be combined with constructor value
arguments:
```
class SomeFunctor {
    …
    T data1;
    const T &data2;
public:
    …
    SomeFunctor(const T& d1, T d2)
        : data1(d1)  // OK
        , data2(d2)  // SERIOUS PROBLEM HERE !!
    {}
};
```

---
template: plain
name: callback_with_lambda
header: ### Callback Via Lambda

By using Lambdas, introduced with C++11, it is possible to place the code
executed as call-back visually in the argument with which is handed over. As
functors can only be defined **outside** other functions this would move the
code (much) further away.

#### Basic Lambda Example

In the most simple case a lambda will only access the argument handed over in
its (later) call and maybe global variables/objects:
```
std::for_each(v.begin(), v.end(),
              [](const std::string &s) {
                      std::cout << s << '\n';
              }
);
```

.F[:
With modern IDEs that show the implementation of a function in a pop-up window
when the mouse cursor hovers over a function name that is not a substantial
disadavantage.
]

---
template: plain
header: #### Lambda With Capture List

*Capture lists* provide access to variables or arguments from the local scope
of a lambda:
```
void foo(std::ostream &output) {
…
std::for_each(v.begin(), v.end(),
              [&output](const std::string &s) {
                  output << s << '\n';
              }
);
```

Identifier names will simply be listed separated via a comma; per default a
copy is made but prepending an ampersand (`&`) requests handing over as
reference.

---
template: plain
header: #### Lambda With Private Data

A functor may have private data solely accessible in its `operator()`.

C++11 lambdas are restricted in this respect: purely local data cannot be
completely private as they can only come in via the capture list. Hence the
actual data must exist outside the lambda:._[]
```
void foo(std::ostream &output) {
    …
    int line_nr = 0;
    std::for_each(v.begin(), v.end(),
                  [&line_nr, &output](const std::string &s) {
                      output << ++line_nr << s << '\n';
                  }
    );
    …
}
```

The above code shows the general principle of "lambda local data" that is
accessed not only for reading but also for modified.

.F[:
An additional level of bracing may be added to limit the scope of variables
only used inside a single lambda.
]

---
template: plain
name: cpp14_lambda_extensions
header: ### C++14 Extensions to Lambdas

With C++14 lambdas have been further extended:._[]

* Lambdas may use [`auto` as argument type](#cpp14_lambda_auto_arg), thus
  allowing generic lambdas, similar to functors with a templated `operator()`.

* The capture list may define so-called [init-captures](#cpp14_lambda_init),
  giving the same options as local (independent) data members of a functor,
  with (possibly context dependant) initialisation.

.F[:
For the curious: C++14 also fixed a minor oversight in the lambda syntax
specification of C++11: While the idea was to allow the lambda argument list
to be completely dropped if empty, including its parentheses if empty, that
was forgotten in the syntax for `mutable` lambdas.
]

---
template: plain
name: cpp14_lambda_auto_arg
header: #### C++14 `auto`-typed Lambda Arguments

Prior to C++14 argument types of lambdas had to be spelled out explicitly,
which could sometimes be wordy and inconvenient:._[]
```
std::map<std::string, unsigned long> m;
…
std::map<std::string, unsigned long> other;
std::copy_if(m.cbegin(), m.cend(), std::inserter(other),
             [](const std::pair<std::string, unsigned long> &e) {
                 return e.second != 0;
             });
```

Clearly, in the above scenario `auto`-typed arguments for lambdas offer a big
simplification:
```
std::copy_if(m.cbegin(), m.cend(), std::inserter(other),
             [](const auto &e) { return e.second != 0; });
```

.F[:
The problem could be slightly alleviated if there were a type definition for the
map, say `C`, allowing to refer to the element type inside as `C::value_type`
(or if `C` were a dependant type as `typename C::value_type`).
]

---
template: plain
header: #### C++14 Lambda Init-Captures

This C++14 extension allows a third form of capture:
```
// assuming local scope here
SomeType local;
…
… [local]( … ) { // capturing by value-copy
   … // access local copy read-only
  } …
… [local]( … ) mutable { // capturing by value-copy
    … // access local copy modifiable
  } …
… [&local]( … ) { // capturing by reference
    … // access and possibly modify local in outer scope
  } …
… [mine = local]( … ) { // init-capture (C++14 only)
    … // access mine modifiable, initial value from local
  } …
```

The initialisation of init-captures may also use arbitrary expressions.
```
… [mine = 2*local + 1] ( … ) { … } …
… [mine = std::make_shared<SomeType>(local)] ( … ) { … } …
```

---
template: plain
header: #### Extended Type Deduction for C++14 Lambdas

With the extensions to lambdas in C++14 also two new contexts for type deduction
were introduced:

* In case of `auto`-typed lambda arguments the type deduction rules are the same
  as for template functions (and hence **not** exactly the same as for
  `auto`-typed variables!)

* In case of init-captures the type of the newly introduced identifier is determined
  is like for `auto`-typed variables.

---
template: plain
header: #### Init-Captures and Move-Construction

Init-captures solve a problem that lay outside the capabilities of lambdas as
defined by C++11:

* When capturing by value-copy, only the copy-constructor applies.

  * In an init-capture, if the initialising expression is a temporary, the
    move construction may take place – given a move constructor exists and
    the compiler does not choose to prefer [(N)RVO].

Therefore only init-captures allow the following (assuming `local` is a move-only
type._[] or it is its last use and copying is expensive):
```
… [mine = std::move(local)] ( … ) { … } …
```

.F[:
Like e.g. `std::unique_ptr`, `std::thread`.
]

[(N)RVO]: http://en.wikipedia.org/wiki/Return_value_optimization
[ugly work-around]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3610.html

---
template: plain
header: #### C++14 Init-Capture Pitfalls

One possible pitfall with init-captures is illustrated below.

.W[
Classic (C-style) arrays are treated as value objects captured by value-copy
but decay to pointers (to the first element) in init-captures.._[]
]

But also be sure to understand there are scenarios in which you explicitly
**would want to avoid copying** e.g. to improve performance or reduce memory
footprint!

.pull-left[
Secure capturing of value-copies:
```
auto foo() {
    int data[] = {2, 3, 5, 7};
    return [data]( … ) {
               … // lambda-body
           };
}
```
] 
.pull-right[
Reference to invalidated stack:
```
auto foo() {
    int data[] = {2, 3, 5, 7};
    return [d = data]( … ) {
               … // lambda-body
           };
}
```
]

.F[:
This might be used as an argument to prefer `std::array` over classic arrays, as
then in both cases the content would be copied.
]

---
template: plain
name: predicates_general
header: ### Predicates For Algorithms (General Principle)

Many STL algorithms have a variant to which a selection criterion (predicate)
can be specified in a flexible way. This is the algorithm variant ending in
`_if`.

The following example is meant to demonstrate the principle with an algorithm
that copies every element in a range to some other container, when it matches
the predicate:._[]
```
template<typename T1, typename T2, typename T3>
T2 my_copy_if(T1 from, T1 upto, T2 dest, T3 pred) {
    while (from != upto) {
        const auto tmp = *from++;
        if (pred(tmp))
            *dest++ = tmp;
    }
    return dest;
}
```

.F[:
The STL algorithm `std::copy_if` was introduced only with C++11, though the
STL algorithm `std::remove_copy_if` could be used for the same purpose if the
predicate was inverted.
]

---
template: plain
header: #### Handing Over Predicates

As template the predicate accessed via the argument named `pred` needs to be
a *callable* – that is just something which supports the syntax to be called
like a function:

This allows for

* [a function pointer](#predicate_fptr),
* [a functor](#predicate_functor) und
* [a C++11 lambdas](#predicate_lambda)

as long as such accept an argument of the type of the dereferenced container
iterator (`*from`) and return a `bool`.._[]

.F[:
More precisely: A type that can be converted into a `bool`.
]

The following code counts all the elements of in a container comparing less
than or equal to 42.

---
template: plain
name: predicate_fptr
header: #### Predicate Via Function Pointer

Of course the function must be defined first:
```
bool lt42(int n) { return n < 42; }
```

Then it can be used as predicate:
```
… std::count_if( … , … , lt42);
```
.W[
Many older compilers consider the name of a function which is not followed by
parenthesis as a pointer, i.e. an address in the code segment, and from this
inside `my_copy_if` generate true function call – which may cause a run time
penalty.._[·]
]

.F[:
Since a number of years the GNU compiler family at least at the higher
optimisation levels generate much more efficient code as for tiny functions
like the one used here they just pick-up the implementation and insert the
equivalent code directly at the calls, even for functions **not** explicitly
marked `inline`.
]

---
template: plain
name: predicate_functor
header: #### Predicate Via Functor

At first the functor must be defined:
```
struct Lt42 {
    bool operator()(int n) const { return n < 42; }
};
```

So far it is just a type. To hand it over as argument an object of that type
needs to be instantiated:
```
… std::count_if( … , … , Lt42());  // classic C++
         // or ( … , … , Lt42{});  // since C++11
```
.N[
If `Lt42::operator()` is explicitly or implicitly `inline`._[] the generated
code will be execute faster and often is even smaller compared to handing over
the predicate via a function pointer.
]

.F[:
With respect to GCC (g++) it should be noted that without any optimization,
which is the default or may be be requested with `-O0`, every function will be
compiled into an explicit true function call **even if it is `inline`**.
]

---
template: plain
name: predicate_lambda
header: #### Prädikat mit C++11-Lambda übergeben

Hier ist das Prädikat unmittelbar bei der Übergabe zu sehen:
```
… std::count_if( … , … , [](int n) { return n < 42; });
```

#### Alternative mit Standard-Bibliotheksfunktion

Diese mit C++98 eingeführte Möglichkeit wirkt sehr unleserlich und wird evtl.
auch aus diesem Grund nur selten benutzt:
```
… std::count_if( … , … , std::bind2nd(std::less<int>(), 42));
```

---
template: plain
name: predicate_examples
header: ### Predicates for Algorithms By Example

Finally another example series comparing the various ways to specify predicates
for algorithms:

In the first group there is no flexibility at all, everything is hard-coded for
a special case.

* [Function Pointer			](#predicate_specific_fptr)
* [Functor				](#predicate_specific_functor)
* [Lambda				](#predicate_specific_lambda)

In the seconds group – for which function pointers are not any longer powerful
enough – there is more flexibility, comparing similar approaches that had been
chosen for different reason.

* [Parametrized  Functor		](#predicate_parametrized_functor)
* [Access Local Scope Data Via Functor	](#predicate_capturing_functor)
* [Access Local Scope Data Via Lambda	](#predicate_capturing_lambda)


---
template: plain
name: predicate_specific_fptr
header: #### Predicate Via Specific Function Pointer

This technique has already been used in C programming.

The example prints all values except those comparing equal to 524:
```
bool notEq524(int n) { return n != 524; }

void foo(const std::vector<int> &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 notEq524
    );
    …
}
```

---
template: plain
name: predicate_specific_functor
header: #### Predicate Via Specific Functor

This technique is typical for C++.

Again the example prints all values except those comparing equal to 524:

```
struct NotEq524 {
    bool operator()(int n) const { return n != 524; }
};
void foo(const std::vector<int> &v) {
    …
    copy_if(v.begin(), v.end(),
            std::ostream_iterator<int>(std::cout, " "),
            NotEq524()
    );
    …
}
```

---
template: plain
name: predicate_specific_lambda
header: #### Predicate Via Specific Lambad

And for the third time, now with a C++11 Lambda.

Again all elements except those comparing equal to 524 are printed:
```
void foo(const std::vector &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 [](int n) { return n != 524; }
    );
    …
}
```

---
template: plain
name: predicate_parametrized_functor
header: #### Predicate With More Flexible Functor

The following functor may be used for all "not equal to" comparisons
with `int`-s:

```
class NotEq {
    const int cmp;
public:
    NotEq(int c) : cmp(c) {}
    bool operator()(int n) const { return n != cmp; }
};
…
void foo(const std::vector &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 NotEq(524) // classic C++
          // or: NotEq{524} // since C++11

    );
    …
}
```

---
template: plain
name: predicate_capturing_functor
header: #### Predicate With Functor Accessing Local Context

To access variables or parameters._[] from the local context a functor needs
data members and a constructor to initializes them:
```
void foo(const std::vector &v, int hide) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(cout, " "),
                 NotEq(hide) // classic C++
          // or: NotEq{hide} // since C++11
    );
    …
}
```
.F[:
The parameters of a function are much similar to local variables. The only
difference is they are initialized at the callers choice whenever an actual
call takes place.
]

---
template: plain
name: predicate_capturing_lambda
header: #### Predicate With Lambda Accessing Local Context

To access variables or parameters._[] from the local context a lambda needs to
use a capture list:
```
void foo(const std::vector &v, int hide) {
    …
    std::copy_if(v.begin(), v.end(),
    	         std::ostream_iterator<int>(std::cout, " "),
                 [hide](int n) { return n != hide; }
    );
    …
}
```

.N[
Lambdas within member functions of a class may also name `this` in the capture
list and then directly access all the member data and functions accessible for
the member function in which defined the lambda.
]

.F[:
The parameters of a function are much similar to local variables. The only
difference is they are initialized at the callers choice whenever an actual
call takes place.
]

---
template: plain
name: summary
header: ## Summary

This part

* first covered the various [Iterator categories](#stl_iterator_categories),

* then compared [Call-Backs from Standard Algorithms](#stl_algorithm_interface)
  in the form
  * [Functors](#callback_with_lambda) (= classes with overloaded `operator()`),
  * [Functions](#callback_with_function) (= classic C function pointers), and
  * [Lambdas](#callback_with_lambda) (= function literals, as introduced with
    C++11)

-------------------------------------------------------------------------------

What to do next?
* [Go back to the Agenda](00_topics.html#agenda) and chose a specific part …
  * …  or [continue with next part](04_day2.html),
  * … or with the next (and last) page of this part.

---
template: plain
name: stl_algorithm_tour
header: ## A Standard Algorithms Tour

The tour will be presented "life" – feel free to request stops and/or deeper
coverage at points of specific interest, simply by asking questions.

[Generic Numeric Operations]: http://en.cppreference.com/w/cpp/numeric#Generic_numeric_operations

.I[
Please gather here for coach to show you around :-) …  
at http://en.cppreference.com/w/cpp/algorithm  
]

In case you are ahead of time and have to wait for the tour to start, these are
the major pre-planned stops (= STL algorithms grouped by purpose):

* [Non-Modifying](http://en.cppreference.com/w/cpp/algorithm#Non-modifying_sequence_operations)
  and
  [Modifying Sequence Operations](http://en.cppreference.com/w/cpp/algorithm#Modifying_sequence_operations)
* [Partitioning](http://en.cppreference.com/w/cpp/algorithm#Partioning_operations) and
  [Sorting Operations](http://en.cppreference.com/w/cpp/algorithm#Sorting_operations)
* [Binary Search](http://en.cppreference.com/w/cpp/algorithm#Binary_search_operations_.28on_sorted_ranges.29)
  and
  [Set Operations](http://en.cppreference.com/w/cpp/algorithm#Set_operations_.28on_sorted_ranges.29)
  on Sorted Ranges
* [Heap](http://en.cppreference.com/w/cpp/algorithm#Heap_operations)
  and
  [Minimum/Maximum Operations](http://en.cppreference.com/w/cpp/algorithm#Minimum.2Fmaximum_operations)
* [Numeric Operations](http://en.cppreference.com/w/cpp/algorithm#Numeric_operations)
* [Operations on Uninitialized Memory](http://en.cppreference.com/w/cpp/algorithm#Operations_on_uninitialized_memory)
* [Classic C Library](http://en.cppreference.com/w/cpp/algorithm#C_library)

.F[:
For more exploration and gathering practical experience view the
[Micro Projects](x2_day2.html#stl_algorithm_micro_projects)
on STL algorithms.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
